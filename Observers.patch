From 14cdc1cea7606e79188493129898baec15fe8191 Mon Sep 17 00:00:00 2001
From: trickerer <onlysuffering@gmail.com>
Date: Sat, 2 May 2020 20:04:59 +0700
Subject: [PATCH] Observers

---
 sql/custom/Observers/characters_observers.sql      |   8 +
 src/server/game/Combat/CombatManager.cpp           |   5 +
 src/server/game/DungeonFinding/LFGMgr.cpp          |   4 +
 src/server/game/Entities/Object/Object.cpp         |  22 +
 src/server/game/Entities/Player/Player.cpp         | 112 +++
 src/server/game/Entities/Player/Player.h           |  18 +
 src/server/game/Entities/Unit/Unit.cpp             |  48 ++
 src/server/game/Handlers/BattleGroundHandler.cpp   |  10 +
 src/server/game/Handlers/ChatHandler.cpp           |  36 +
 src/server/game/Handlers/GroupHandler.cpp          |   8 +
 src/server/game/Handlers/TaxiHandler.cpp           |  16 +
 src/server/game/Handlers/TradeHandler.cpp          |  20 +
 src/server/game/Maps/Map.cpp                       |  13 +
 src/server/game/Maps/MapInstanced.cpp              |  14 +
 src/server/game/Maps/MapManager.cpp                |   5 +
 src/server/game/Observers/ObserversMgr.cpp         | 855 +++++++++++++++++++++
 src/server/game/Observers/ObserversMgr.h           | 137 ++++
 src/server/game/Spells/Auras/SpellAuras.cpp        |   5 +
 src/server/game/Spells/Spell.cpp                   |   5 +
 .../scripts/Custom/Observers/ObserversCS.cpp       | 810 +++++++++++++++++++
 src/server/scripts/Custom/custom_script_loader.cpp |   6 +
 src/server/worldserver/worldserver.conf.dist       |  57 ++
 22 files changed, 2214 insertions(+)
 create mode 100644 sql/custom/Observers/characters_observers.sql
 create mode 100644 src/server/game/Observers/ObserversMgr.cpp
 create mode 100644 src/server/game/Observers/ObserversMgr.h
 create mode 100644 src/server/scripts/Custom/Observers/ObserversCS.cpp

diff --git a/sql/custom/Observers/characters_observers.sql b/sql/custom/Observers/characters_observers.sql
new file mode 100644
index 0000000..cfb5ffc
--- /dev/null
+++ b/sql/custom/Observers/characters_observers.sql
@@ -0,0 +1,8 @@
+DROP TABLE IF EXISTS `characters_observers`;
+
+CREATE TABLE `characters_observers` (
+  `guid` int(10) unsigned NOT NULL DEFAULT '0' COMMENT 'Character Global Unique Identifier (low)',
+  `observer` int(10) unsigned NOT NULL DEFAULT '0' COMMENT 'Observer Global Unique Identifier (low)',
+  `flag` tinyint(3) unsigned NOT NULL DEFAULT '1' COMMENT 'Access State Flag',
+  PRIMARY KEY (`guid`,`observer`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Observers System';
diff --git a/src/server/game/Combat/CombatManager.cpp b/src/server/game/Combat/CombatManager.cpp
index 02dff68..a7a5afd 100644
--- a/src/server/game/Combat/CombatManager.cpp
+++ b/src/server/game/Combat/CombatManager.cpp
@@ -44,6 +44,11 @@
         return false;
     if (a->HasUnitState(UNIT_STATE_IN_FLIGHT) || b->HasUnitState(UNIT_STATE_IN_FLIGHT))
         return false;
+    // Observers: exclude observers
+    if ((a->GetTypeId() == TYPEID_PLAYER && a->ToPlayer()->IsObserver()) ||
+        (b->GetTypeId() == TYPEID_PLAYER && b->ToPlayer()->IsObserver()))
+        return false;
+    // End Observers
     if (a->IsFriendlyTo(b) || b->IsFriendlyTo(a))
         return false;
     Player const* playerA = a->GetCharmerOrOwnerPlayerOrPlayerItself();
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
index 56c9fd4..69ccbf6 100644
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -425,6 +425,10 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
     // Check player or group member restrictions
     if (!player->GetSession()->HasPermission(rbac::RBAC_PERM_JOIN_DUNGEON_FINDER))
         joinData.result = LFG_JOIN_NOT_MEET_REQS;
+    // Observers: deny observers
+    else if (player->IsObserver())
+        joinData.result = LFG_JOIN_NOT_MEET_REQS;
+    // End Observers
     else if (player->InBattleground() || player->InArena() || player->InBattlegroundQueue())
         joinData.result = LFG_JOIN_USING_BG_SYSTEM;
     else if (player->HasAura(LFG_SPELL_DUNGEON_DESERTER))
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index 706d736..d9fee07 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -49,6 +49,10 @@
 #include "World.h"
 #include <G3D/Vector3.h>
 
+// Observers
+#include "ObserversMgr.h"
+// End Observers
+
 constexpr float VisibilityDistances[AsUnderlyingType(VisibilityDistanceType::Max)] =
 {
     DEFAULT_VISIBILITY_DISTANCE,
@@ -1531,6 +1535,11 @@ float WorldObject::GetSightRange(WorldObject const* target) const
 
 bool WorldObject::CanSeeOrDetect(WorldObject const* obj, bool ignoreStealth, bool distanceCheck, bool checkAlert) const
 {
+    // Observers
+    if (obj->GetTypeId() == TYPEID_PLAYER && obj->ToPlayer()->IsObserver())
+        return false;
+    // End Observers
+
     if (this == obj)
         return true;
 
@@ -2573,6 +2582,12 @@ SpellMissInfo WorldObject::SpellHitResult(Unit* victim, SpellInfo const* spellIn
 
 void WorldObject::SendSpellMiss(Unit* target, uint32 spellID, SpellMissInfo missInfo)
 {
+    // Observers: send combat text to observers
+    if (GetTypeId() == TYPEID_PLAYER)
+        if (ObserversMgr* mgr = ToPlayer()->GetObserversMgr())
+            mgr->SendToObservers(SMSG_SPELLLOGMISS, target, &spellID, &missInfo);
+    // End Observers
+
     WorldPacket data(SMSG_SPELLLOGMISS, (4 + 8 + 1 + 4 + 8 + 1));
     data << uint32(spellID);
     data << uint64(GetGUID());
@@ -2830,6 +2845,13 @@ bool WorldObject::IsValidAttackTarget(WorldObject const* target, SpellInfo const
 {
     ASSERT(target);
 
+    // Observers: prevent combat
+    if (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->IsObserver())
+        return false;
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->IsObserver())
+        return false;
+    // End Observers
+
     // some positive spells can be casted at hostile target
     bool isPositiveSpell = bySpell && bySpell->IsPositive();
 
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 595614c..a377ac5 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -102,6 +102,10 @@
 #include "WorldSession.h"
 #include "WorldStatePackets.h"
 
+// Observers
+#include "ObserversMgr.h"
+// End Observers
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 #define PLAYER_SKILL_INDEX(x)       (PLAYER_SKILL_INFO_1_1 + ((x)*3))
@@ -409,6 +413,10 @@ Player::Player(WorldSession* session): Unit(true)
     m_reputationMgr = new ReputationMgr(this);
 
     m_groupUpdateTimer.Reset(5000);
+
+    // Observers
+    _observersMgr = nullptr;
+    // End Observers
 }
 
 Player::~Player()
@@ -448,6 +456,11 @@ Player::~Player()
     delete m_reputationMgr;
     delete _cinematicMgr;
 
+    // Observers: cleanup
+    if (_observersMgr)
+        delete _observersMgr;
+    // End Observers
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1358,6 +1371,10 @@ void Player::Update(uint32 p_time)
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
 
+    // Observers
+    if (_observersMgr)
+        _observersMgr->UpdateMap(p_time);
+    // End Observers
 }
 
 void Player::setDeathState(DeathState s)
@@ -1633,6 +1650,9 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
 
     MapEntry const* mEntry = sMapStore.LookupEntry(mapid);
 
+    // Observers: skip this condition
+    if (!IsObserver())
+    // End Oberservers
     // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
     // don't let gm level > 1 either
     if (!InBattleground() && mEntry->IsBattlegroundOrArena())
@@ -1722,6 +1742,9 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
     }
     else
     {
+        // Observers: skip check
+        if (!IsObserver())
+        // End Observers
         if (GetClass() == CLASS_DEATH_KNIGHT && GetMapId() == 609 && !IsGameMaster() && !HasSpell(50977))
             return false;
 
@@ -1734,6 +1757,11 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         if (sMapMgr->PlayerCannotEnter(mapid, this, false))
             return false;
 
+        // Observers: send observers home for now so they will not be the last players on the map
+        if (_observersMgr)
+            _observersMgr->OnTeleportFar();
+        // End Observers
+
         //I think this always returns true. Correct me if I am wrong.
         // If the map is not created, assume it is possible to enter it.
         // It will be created in the WorldPortAck.
@@ -1901,6 +1929,13 @@ void Player::ProcessDelayedOperations()
     m_DelayedOperations = 0;
 }
 
+// Observers
+bool Player::IsObserver() const
+{
+    return _observersMgr && _observersMgr->GetAcceptor() != nullptr;
+}
+// End Observers
+
 void Player::AddToWorld()
 {
     ///- Do not add/remove the player from the object storage
@@ -1950,6 +1985,9 @@ void Player::RemoveFromWorld()
     {
         if (WorldObject* viewpoint = GetViewpoint())
         {
+            // Observers: check if logging out (normal)
+            if (!(IsObserver() && GetSession()->isLogingOut()))
+            // End Observers
             TC_LOG_ERROR("entities.player", "Player::RemoveFromWorld: Player '%s' (%s) has viewpoint (Entry:%u, Type: %u) when removed from world",
                 GetName().c_str(), GetGUID().ToString().c_str(), viewpoint->GetEntry(), viewpoint->GetTypeId());
             SetViewpoint(viewpoint, false);
@@ -4410,6 +4448,10 @@ void Player::DeleteFromDB(ObjectGuid playerguid, uint32 accountId, bool updateRe
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
 
+            // Observers: remove from observers table
+            CharacterDatabase.PExecute("DELETE FROM characters_observers WHERE guid = %u OR observer = %u", guid, guid);
+            // End Observers
+
             Corpse::DeleteFromDB(playerguid, trans);
             break;
         }
@@ -6415,6 +6457,11 @@ void Player::CheckAreaExploreAndOutdoor()
     if (IsInFlight())
         return;
 
+    // Observers: prevent players from exploring and everything else
+    if (IsObserver())
+        return;
+    // End Observers
+
     if (sWorld->getBoolConfig(CONFIG_VMAP_INDOOR_CHECK) && !IsOutdoors())
         RemoveAurasWithAttribute(SPELL_ATTR0_OUTDOORS_ONLY);
 
@@ -7000,6 +7047,11 @@ uint32 Player::GetZoneIdFromDB(ObjectGuid guid)
 
 void Player::UpdateArea(uint32 newArea)
 {
+    // Observers: skip
+    if (IsObserver())
+        return;
+    // End Observers
+
     // FFA_PVP flags are area and not zone id dependent
     // so apply them accordingly
     m_areaUpdateId = newArea;
@@ -7039,6 +7091,11 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
     if (!IsInWorld())
         return;
 
+    // Observers: skip
+    if (IsObserver())
+        return;
+    // End Observers
+
     uint32 const oldZone = m_zoneUpdateId;
     m_zoneUpdateId = newZone;
     m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;
@@ -10543,6 +10600,11 @@ InventoryResult Player::CanStoreItem_InInventorySlots(uint8 slot_begin, uint8 sl
 
 InventoryResult Player::CanStoreItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, uint32 entry, uint32 count, Item* pItem, bool swap, uint32* no_space_count) const
 {
+    // Observers: deny all loot for observers
+    if (IsObserver())
+        return EQUIP_ERR_ITEM_NOT_FOUND;
+    // End Observers
+
     TC_LOG_DEBUG("entities.player.items", "Player::CanStoreItem: Bag: %u, Slot: %u, Item: %u, Count: %u", bag, slot, entry, count);
 
     ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
@@ -14144,6 +14206,11 @@ void Player::SendNewItem(Item* item, uint32 count, bool received, bool created,
     data << uint32(count);                                  // count of items
     data << uint32(GetItemCount(item->GetEntry()));         // count of items in inventory
 
+    // Observers: send message to observers
+    if (_observersMgr && ObserversMgr::SendItemPackets())
+        _observersMgr->SendToObservers(&data);
+    // End Observers
+
     if (broadcast && GetGroup())
         GetGroup()->BroadcastPacket(&data, true);
     else
@@ -18935,6 +19002,11 @@ void Player::UnbindInstance(BoundInstancesMap::iterator &itr, Difficulty difficu
 
 InstancePlayerBind* Player::BindToInstance(InstanceSave* save, bool permanent, BindExtensionState extendState, bool load)
 {
+    // Observers: skip observers
+    if (IsObserver())
+        return nullptr;
+    // End Observers
+
     if (save)
     {
         InstancePlayerBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
@@ -19188,6 +19260,11 @@ bool Player::CheckInstanceValidity(bool /*isLogin*/)
     if (IsGameMaster())
         return true;
 
+    // Observers
+    if (IsObserver())
+        return true;
+    // End Observers
+
     // non-instances are always valid
     Map* map = FindMap();
     if (!map || !map->IsDungeon())
@@ -19476,6 +19553,21 @@ void Player::SaveToDB(bool create /*=false*/)
         stmt->setUInt8(index++, GetRestState());
         stmt->setUInt32(index++, GetUInt32Value(PLAYER_FLAGS));
 
+        //Observers should save their orig position
+        if (_observersMgr && _observersMgr->GetAcceptor())
+        {
+            float origx, origy, origz, origo;
+            _observersMgr->GetOrigPos(origx, origy, origz, origo);
+            stmt->setUInt16(index++, (uint16)_observersMgr->GetOrigMapId());
+            stmt->setUInt32(index++, (uint32)GetInstanceId());
+            stmt->setUInt8(index++, (uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4));
+            stmt->setFloat(index++, finiteAlways(origx));
+            stmt->setFloat(index++, finiteAlways(origy));
+            stmt->setFloat(index++, finiteAlways(origz));
+            stmt->setFloat(index++, finiteAlways(origo));
+        }
+        else
+        //End Observers
         if (!IsBeingTeleported())
         {
             stmt->setUInt16(index++, (uint16)GetMapId());
@@ -19522,6 +19614,11 @@ void Player::SaveToDB(bool create /*=false*/)
         stmt->setUInt16(index++, (uint16)m_ExtraFlags);
         stmt->setUInt8(index++,  m_stableSlots);
         stmt->setUInt16(index++, (uint16)m_atLoginFlags);
+        //Observers: orig zone Id
+        if (_observersMgr && _observersMgr->GetAcceptor())
+            stmt->setUInt16(index++, (uint16)_observersMgr->GetOrigZoneId());
+        else
+        //End Observers
         stmt->setUInt16(index++, GetZoneId());
         stmt->setUInt32(index++, uint32(m_deathExpireTime));
 
@@ -22320,6 +22417,11 @@ bool Player::HaveAtClient(Object const* u) const
 
 bool Player::IsNeverVisible() const
 {
+    // Observers: hide observers
+    if (IsObserver())
+        return true;
+    // End Observers
+
     if (Unit::IsNeverVisible())
         return true;
 
@@ -24275,6 +24377,11 @@ void Player::SetOriginalGroup(Group* group, int8 subgroup)
 
 void Player::ProcessTerrainStatusUpdate(ZLiquidStatus status, Optional<LiquidData> const& liquidData)
 {
+    // Observers: prevent players from suffocating
+    if (IsObserver())
+        return;
+    // End Observers
+
     // process liquid auras using generic unit code
     Unit::ProcessTerrainStatusUpdate(status, liquidData);
 
@@ -25498,6 +25605,11 @@ void Player::ResummonPetTemporaryUnSummonedIfAny()
 
 bool Player::IsPetNeedBeTemporaryUnsummoned() const
 {
+    // Observers: prevent pet resummoning
+    if (IsObserver())
+        return true;
+    // End Observers
+
     return !IsInWorld() || !IsAlive() || IsMounted() /*+in flight*/;
 }
 
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 97835fb..f59ae96 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -79,6 +79,10 @@ enum ItemClass : uint8;
 enum LootError : uint8;
 enum LootType : uint8;
 
+// Observers
+class ObserversMgr;
+// End Observers
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2173,6 +2177,16 @@ class TC_GAME_API Player : public Unit, public GridObject<Player>
 
         std::string GetDebugInfo() const override;
 
+        /*********************************************************/
+        /***                 OBSERVERS SYSTEM                  ***/
+        /*********************************************************/
+        void SetObserversMgr(ObserversMgr* mgr) { ASSERT (!_observersMgr); _observersMgr = mgr; }
+        ObserversMgr* GetObserversMgr() const { return _observersMgr; }
+        bool IsObserver() const;
+        /*********************************************************/
+        /***                END OBSERVERS SYSTEM               ***/
+        /*********************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         GuidList WhisperList;
@@ -2429,6 +2443,10 @@ class TC_GAME_API Player : public Unit, public GridObject<Player>
         TimeTrackerSmall m_groupUpdateTimer;
 
     private:
+        // Observers
+        ObserversMgr* _observersMgr;
+        // End Observers
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 6263e03..a043e57 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -76,6 +76,10 @@
 #include "WorldSession.h"
 #include <cmath>
 
+// Observers
+#include "ObserversMgr.h"
+// End Observers
+
 float baseMoveSpeed[MAX_MOVE_TYPE] =
 {
     2.5f,                  // MOVE_WALK
@@ -5122,6 +5126,12 @@ void Unit::RemoveAllGameObjects()
 
 void Unit::SendSpellNonMeleeDamageLog(SpellNonMeleeDamage* log)
 {
+    // Observers: send combat text to observers
+    if (GetTypeId() == TYPEID_PLAYER && log->attacker == this)
+        if (ObserversMgr* mgr = ToPlayer()->GetObserversMgr())
+            mgr->SendToObservers(SMSG_SPELLNONMELEEDAMAGELOG, log);
+    // End Observers
+
     WorldPacket data(SMSG_SPELLNONMELEEDAMAGELOG, (16+4+4+4+1+4+4+1+1+4+4+1)); // we guess size
     data << log->target->GetPackGUID();
     data << log->attacker->GetPackGUID();
@@ -5190,6 +5200,21 @@ void Unit::SendSpellNonMeleeDamageLog(Unit* target, uint32 spellID, uint32 damag
 
 void Unit::SendPeriodicAuraLog(SpellPeriodicAuraLogInfo* pInfo)
 {
+    // Observers: send combat text to observers
+    switch (pInfo->auraEff->GetAuraType())
+    {
+        //only effects with combat text
+        case SPELL_AURA_PERIODIC_DAMAGE:
+        case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
+            if (Player* caster = ObjectAccessor::FindPlayer(pInfo->auraEff->GetCasterGUID()))
+                if (ObserversMgr* mgr = caster->GetObserversMgr())
+                    mgr->SendToObservers(SMSG_PERIODICAURALOG, pInfo, this);
+            break;
+        default:
+            break;
+    }
+    // End Observers
+
     AuraEffect const* aura = pInfo->auraEff;
 
     WorldPacket data(SMSG_PERIODICAURALOG, 30);
@@ -5246,6 +5271,12 @@ void Unit::SendSpellDamageResist(Unit* target, uint32 spellId)
 
 void Unit::SendSpellDamageImmune(Unit* target, uint32 spellId)
 {
+    // Observers: send combat text to observers
+    if (GetTypeId() == TYPEID_PLAYER)
+        if (ObserversMgr* mgr = ToPlayer()->GetObserversMgr())
+            mgr->SendToObservers(SMSG_SPELLORDAMAGE_IMMUNE, target, &spellId);
+    // End Observers
+
     WorldPacket data(SMSG_SPELLORDAMAGE_IMMUNE, 8+8+4+1);
     data << uint64(GetGUID());
     data << uint64(target->GetGUID());
@@ -5256,6 +5287,12 @@ void Unit::SendSpellDamageImmune(Unit* target, uint32 spellId)
 
 void Unit::SendAttackStateUpdate(CalcDamageInfo* damageInfo)
 {
+    // Observers: send combat text to observers
+    if (GetTypeId() == TYPEID_PLAYER && damageInfo->Attacker == this)
+        if (ObserversMgr* mgr = ToPlayer()->GetObserversMgr())
+            mgr->SendToObservers(SMSG_ATTACKERSTATEUPDATE, damageInfo);
+    // End Observers
+
     uint32 count = 1;
     if (damageInfo->Damages[1].Damage || damageInfo->Damages[1].Absorb || damageInfo->Damages[1].Resist)
         ++count;
@@ -6326,6 +6363,12 @@ void Unit::UnsummonAllTotems()
 
 void Unit::SendHealSpellLog(HealInfo& healInfo, bool critical /*= false*/)
 {
+    // Observers: send combat text to observers
+    if (GetTypeId() == TYPEID_PLAYER && healInfo.GetHealer() == this)
+        if (ObserversMgr* mgr = ToPlayer()->GetObserversMgr())
+            mgr->SendToObservers(SMSG_SPELLHEALLOG, &healInfo, &critical);
+    // End Observers
+
     // we guess size
     WorldPacket data(SMSG_SPELLHEALLOG, 8 + 8 + 4 + 4 + 4 + 4 + 1 + 1);
     data << healInfo.GetTarget()->GetPackGUID();
@@ -10267,6 +10310,11 @@ bool Unit::IsPolymorphed() const
 
 void Unit::RecalculateObjectScale()
 {
+    // Observers
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->IsObserver())
+        return;
+    // End Observers
+
     int32 scaleAuras = GetTotalAuraModifier(SPELL_AURA_MOD_SCALE) + GetTotalAuraModifier(SPELL_AURA_MOD_SCALE_2);
     float scale = GetNativeObjectScale() + CalculatePct(1.0f, scaleAuras);
     float scaleMin = GetTypeId() == TYPEID_PLAYER ? 0.1 : 0.01;
diff --git a/src/server/game/Handlers/BattleGroundHandler.cpp b/src/server/game/Handlers/BattleGroundHandler.cpp
index 9245c22..a9371ce 100644
--- a/src/server/game/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Handlers/BattleGroundHandler.cpp
@@ -109,6 +109,11 @@ void WorldSession::HandleBattlemasterJoinOpcode(WorldPacket& recvData)
     if (_player->InBattleground())
         return;
 
+    // Observers
+    if (_player->IsObserver())
+        return;
+    // End Observers
+
     // get bg instance or bg template if instance not found
     Battleground* bg = nullptr;
     if (instanceId)
@@ -623,6 +628,11 @@ void WorldSession::HandleBattlemasterJoinArena(WorldPacket& recvData)
     if (_player->InBattleground())
         return;
 
+    // Observers
+    if (_player->IsObserver())
+        return;
+    // End Observers
+
     Creature* unit = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_BATTLEMASTER);
     if (!unit)
         return;
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index 91475eb..3cfa199 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -270,6 +270,26 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             return;
     }
 
+    // Observers: disable some chat message types
+    switch (type)
+    {
+        case CHAT_MSG_SAY:
+        case CHAT_MSG_YELL:
+        case CHAT_MSG_EMOTE:
+        case CHAT_MSG_TEXT_EMOTE:
+        {
+            if (sender->IsObserver())
+            {
+                SendNotification("You can't do that while in observer mode");
+                return;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+    // End Observers
+
     switch (type)
     {
         case CHAT_MSG_SAY:
@@ -571,6 +591,14 @@ void WorldSession::HandleEmoteOpcode(WorldPackets::Chat::EmoteClient& packet)
     if (!_player->IsAlive() || _player->HasUnitState(UNIT_STATE_DIED))
         return;
 
+    // Observers: disable emotions
+    if (GetPlayer()->IsObserver())
+    {
+        SendNotification("You can't do that while in observer mode");
+        return;
+    }
+    // End Observers
+
     sScriptMgr->OnPlayerEmote(_player, emoteId);
     _player->HandleEmoteCommand(emoteId);
 }
@@ -619,6 +647,14 @@ void WorldSession::HandleTextEmoteOpcode(WorldPacket& recvData)
         return;
     }
 
+    // Observers: disable public chat
+    if (GetPlayer()->IsObserver())
+    {
+        SendNotification("You can't do that while in observer mode");
+        return;
+    }
+    // End Observers
+
     uint32 text_emote, emoteNum;
     ObjectGuid guid;
 
diff --git a/src/server/game/Handlers/GroupHandler.cpp b/src/server/game/Handlers/GroupHandler.cpp
index 2597667..dee9c3d 100644
--- a/src/server/game/Handlers/GroupHandler.cpp
+++ b/src/server/game/Handlers/GroupHandler.cpp
@@ -92,6 +92,14 @@ void WorldSession::HandleGroupInviteOpcode(WorldPacket& recvData)
         return;
     }
 
+    // Observers: deny groups for observers
+    if (invitingPlayer->IsObserver() || invitedPlayer->IsObserver())
+    {
+        SendPartyResult(PARTY_OP_INVITE, membername, ERR_PLAYER_WRONG_FACTION);
+        return;
+    }
+    // End Observers
+
     // restrict invite to GMs
     if (!sWorld->getBoolConfig(CONFIG_ALLOW_GM_GROUP) && !invitingPlayer->IsGameMaster() && invitedPlayer->IsGameMaster())
     {
diff --git a/src/server/game/Handlers/TaxiHandler.cpp b/src/server/game/Handlers/TaxiHandler.cpp
index 2160a73..d1c1fee 100644
--- a/src/server/game/Handlers/TaxiHandler.cpp
+++ b/src/server/game/Handlers/TaxiHandler.cpp
@@ -118,6 +118,11 @@ void WorldSession::SendDoFlight(uint32 mountDisplayId, uint32 path, uint32 pathN
     if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
+    // Observers
+    if (GetPlayer()->IsObserver())
+        return;
+    // End Observers
+
     if (mountDisplayId)
         GetPlayer()->Mount(mountDisplayId);
 
@@ -173,6 +178,12 @@ void WorldSession::HandleActivateTaxiExpressOpcode (WorldPacket& recvData)
         SendActivateTaxiReply(ERR_TAXITOOFARAWAY);
         return;
     }
+
+    // Observers
+    if (GetPlayer()->IsObserver())
+        return;
+    // End Observers
+
     std::vector<uint32> nodes;
 
     for (uint32 i = 0; i < node_count; ++i)
@@ -265,6 +276,11 @@ void WorldSession::HandleActivateTaxiOpcode(WorldPacket& recvData)
         return;
     }
 
+    // Observers
+    if (GetPlayer()->IsObserver())
+        return;
+    // End Observers
+
     if (!GetPlayer()->isTaxiCheater())
     {
         if (!GetPlayer()->m_taxi.IsTaximaskNodeKnown(nodes[0]) || !GetPlayer()->m_taxi.IsTaximaskNodeKnown(nodes[1]))
diff --git a/src/server/game/Handlers/TradeHandler.cpp b/src/server/game/Handlers/TradeHandler.cpp
index 22f3bdb..f11bfe0 100644
--- a/src/server/game/Handlers/TradeHandler.cpp
+++ b/src/server/game/Handlers/TradeHandler.cpp
@@ -268,6 +268,17 @@ void WorldSession::HandleAcceptTradeOpcode(WorldPacket& /*recvPacket*/)
     my_trade->SetAccepted(true);
 
     TradeStatusInfo info;
+
+    // Observers
+    if (_player->IsObserver() || trader->IsObserver())
+    {
+        info.Status = TRADE_STATUS_TARGET_TO_FAR;
+        SendTradeStatus(info);
+        my_trade->SetAccepted(false);
+        return;
+    }
+    // End Observers
+
     if (!_player->IsWithinDistInMap(trader, TRADE_DISTANCE, false))
     {
         info.Status = TRADE_STATUS_TARGET_TO_FAR;
@@ -669,6 +680,15 @@ void WorldSession::HandleInitiateTradeOpcode(WorldPacket& recvPacket)
         return;
     }
 
+    // Observers
+    if (pOther->IsObserver() || GetPlayer()->IsObserver())
+    {
+        info.Status = TRADE_STATUS_BUSY;
+        SendTradeStatus(info);
+        return;
+    }
+    // End Observers
+
     if (pOther->GetSession()->isLogingOut())
     {
         info.Status = TRADE_STATUS_TARGET_LOGOUT;
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 105898a..e4b02b7 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -3547,6 +3547,9 @@ uint32 Map::GetPlayersCountExceptGMs() const
 {
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
+        // Observers: don't count observers
+        if (!itr->GetSource()->IsObserver())
+        // End Observers
         if (!itr->GetSource()->IsGameMaster())
             ++count;
     return count;
@@ -3714,6 +3717,11 @@ Map::EnterState InstanceMap::CannotEnter(Player* player)
     if (player->IsGameMaster())
         return Map::CannotEnter(player);
 
+    // Observers: allow observers
+    if (player->IsObserver())
+        return Map::CannotEnter(player);
+    // End Observers
+
     // cannot enter if the instance is full (player cap), GMs don't count
     uint32 maxPlayers = GetMaxPlayers();
     if (GetPlayersCountExceptGMs() >= maxPlayers)
@@ -4193,6 +4201,11 @@ Map::EnterState BattlegroundMap::CannotEnter(Player* player)
         return CANNOT_ENTER_ALREADY_IN_MAP;
     }
 
+    // Observers: allow observers
+    if (player->IsObserver())
+        return Map::CannotEnter(player);
+    // End Observers
+
     if (player->GetBattlegroundId() != GetInstanceId())
         return CANNOT_ENTER_INSTANCE_BIND_MISMATCH;
 
diff --git a/src/server/game/Maps/MapInstanced.cpp b/src/server/game/Maps/MapInstanced.cpp
index 49166dc..c16fbd1 100644
--- a/src/server/game/Maps/MapInstanced.cpp
+++ b/src/server/game/Maps/MapInstanced.cpp
@@ -28,6 +28,10 @@
 #include "VMapFactory.h"
 #include "World.h"
 
+// Observers
+#include "ObserversMgr.h"
+// End Observers
+
 MapInstanced::MapInstanced(uint32 id, time_t expiry) : Map(id, expiry, 0, DUNGEON_DIFFICULTY_NORMAL)
 {
     // fill with zero
@@ -119,6 +123,16 @@ Map* MapInstanced::CreateInstanceForPlayer(uint32 mapId, Player* player, uint32
     Map* map = nullptr;
     uint32 newInstanceId = 0;                       // instanceId of the resulting map
 
+    // Observers: get target's instance Id
+    if (player->IsObserver())
+    {
+        newInstanceId = player->GetObserversMgr()->GetAcceptor()->GetInstanceId();
+        map = FindInstanceMap(newInstanceId);
+        ASSERT(map);
+        return map;
+    }
+    // End Observers
+
     if (IsBattlegroundOrArena())
     {
         // instantiate or find existing bg map for player
diff --git a/src/server/game/Maps/MapManager.cpp b/src/server/game/Maps/MapManager.cpp
index 81fe7e3..c5f0ab3 100644
--- a/src/server/game/Maps/MapManager.cpp
+++ b/src/server/game/Maps/MapManager.cpp
@@ -132,6 +132,11 @@ Map::EnterState MapManager::PlayerCannotEnter(uint32 mapid, Player* player, bool
     if (!entry->IsDungeon())
         return Map::CAN_ENTER;
 
+    // Observers: allow observers
+    if (player->IsObserver())
+        return Map::CAN_ENTER;
+    // End Observers
+
     InstanceTemplate const* instance = sObjectMgr->GetInstanceTemplate(mapid);
     if (!instance)
         return Map::CANNOT_ENTER_UNINSTANCED_DUNGEON;
diff --git a/src/server/game/Observers/ObserversMgr.cpp b/src/server/game/Observers/ObserversMgr.cpp
new file mode 100644
index 0000000..eae63b8
--- /dev/null
+++ b/src/server/game/Observers/ObserversMgr.cpp
@@ -0,0 +1,855 @@
+#include "ObserversMgr.h"
+#include "CharacterCache.h"
+#include "Chat.h"
+#include "Config.h"
+#include "DatabaseWorkerPool.h"
+#include "Language.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "Player.h"
+#include "SpellAuraEffects.h"
+//#include "WorldSession.h"
+
+/*
+Observers system by Trickerer <https://github.com/trickerer/Observers>
+VERSION: 1.0.19b
+*/
+
+//6908 invisible transparancy 0%, sound only
+//7804 invisible transparancy 0% tiny no weapon bunny icon, sound
+//22452 invisible no weapon
+#define SPELL_ROOT_SELF 31366 // RAF (hidden)
+#define MODELID_INVISIBLE 7804
+//#define SPELL_TRANSPARENCY_100 37803 // Transparency 100% visible debuff //
+#define ROOT_PERIOD 5000
+
+//config
+bool _enableObservers;
+uint16 _maxObservers;
+bool _enableObserversDungeons;
+bool _enableObserversRaids;
+bool _enableObserversBGs;
+bool _enableObserversArenas;
+bool _enableSneaks;
+bool _sendPacketsCombat;
+bool _sendPacketsItem;
+
+bool __obsfirstload = true;
+
+ObserversMgr::ObserversMgr(Player* const observed) : _owner(observed), _acceptor(nullptr)
+{
+    ErrorSent = false;
+    _sneakPeak = false;
+    _needUpdate = false;
+    _autoAllow = false;
+    _autoForbid = false;
+    _rootTimer = 0;
+    _loadAccessList();
+
+    LoadConfig();
+
+    _owner->SetObserversMgr(this);
+}
+ObserversMgr::~ObserversMgr()
+{
+    RemoveAllObservers();
+    _unloadAccessList();
+
+    if (_acceptor)
+        _acceptor->GetObserversMgr()->RemoveObserver(_owner->GetGUID().GetCounter(), OBSERVER_REMOVE_LOGOUT);
+
+    ASSERT(!_acceptor);
+}
+
+void ObserversMgr::LoadConfig(bool force)
+{
+    if (__obsfirstload)
+        __obsfirstload = false;
+    else if (!force)
+        return;
+
+    _enableObservers         = sConfigMgr->GetBoolDefault("Observers.Enable", true);
+    _maxObservers            = sConfigMgr->GetIntDefault("Observers.MaxObservers", 0);
+    _enableObserversDungeons = sConfigMgr->GetBoolDefault("Observers.Dungeon", true);
+    _enableObserversRaids    = sConfigMgr->GetBoolDefault("Observers.Raid", true);
+    _enableObserversBGs      = sConfigMgr->GetBoolDefault("Observers.BG", true);
+    _enableObserversArenas   = sConfigMgr->GetBoolDefault("Observers.Arena", true);
+    _enableSneaks            = sConfigMgr->GetBoolDefault("Observers.Sneaks", true);
+    _sendPacketsCombat       = sConfigMgr->GetBoolDefault("Observers.SendPackets.Combat", false);
+    _sendPacketsItem         = sConfigMgr->GetBoolDefault("Observers.SendPackets.Item", true);
+}
+
+bool ObserversMgr::IsObserverModEnabled()
+{
+    return _enableObservers;
+}
+
+bool ObserversMgr::SneaksEnabled()
+{
+    return _enableSneaks;
+}
+
+//bool ObserversMgr::SendCombatPackets()
+//{
+//    return _sendPacketsCombat;
+//}
+
+bool ObserversMgr::SendItemPackets()
+{
+    return _sendPacketsItem;
+}
+
+uint16 ObserversMgr::GetObserversCountWithoutSneaks() const
+{
+    uint16 count = 0;
+    for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+        if (!IsSneak(itr->second))
+            ++count;
+
+    return count;
+}
+
+uint16 ObserversMgr::GetMaxObservers()
+{
+    return _maxObservers ? _maxObservers : std::numeric_limits<uint16>::max();
+}
+//Only called from Player::Update(uint32)
+void ObserversMgr::UpdateMap(uint32 diff)
+{
+    _rootTimer += diff;
+
+    if (_needUpdate)
+    {
+        _needUpdate = false;
+        _storeAccessList();
+    }
+
+    if (_autoAllow || _autoForbid)
+    {
+        for (ObserverAccessList::iterator itr = _accessList.begin(); itr != _accessList.end(); ++itr)
+        {
+            if (itr->second == OBSERVER_FLAG_PENDING)
+            {
+                if (_autoAllow)
+                {
+                    AllowObserver(itr->first);
+                    //itr->second = OBSERVER_FLAG_ALLOWED;
+                    if (Player* observer = ObjectAccessor::FindPlayerByLowGUID(itr->first))
+                    {
+                        ChatHandler ch(observer->GetSession());
+                        ch.PSendSysMessage("You are now allowed to observe %s", _owner->GetName().c_str());
+                        //if (CanAddObserver(observer))
+                        //    AddObserver(observer);
+                    }
+                }
+                else if (_autoForbid)
+                {
+                    ForbidObserver(itr->first);
+                    //itr->second = OBSERVER_FLAG_FORBIDDEN;
+                }
+            }
+        }
+    }
+
+    if (!_owner->IsInWorld() || !MapManager::IsValidMapCoord(*_owner) || _owner->IsBeingTeleported())
+        return;
+
+    if (_observers.empty())
+        return;
+
+    Player* observer;
+    if (_rootTimer >= ROOT_PERIOD)
+    {
+        _rootTimer = 0;
+        for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+        {
+            observer = itr->second;
+            if (Aura* root = observer->GetAura(SPELL_ROOT_SELF))
+                root->RefreshDuration();
+        }
+    }
+
+    for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+    {
+        observer = itr->second;
+
+        if (!observer->IsInWorld() || observer->IsBeingTeleported())
+            continue;
+
+        if (observer->GetMap() != _owner->GetMap())
+        {
+            if (observer->GetGuidValue(PLAYER_FARSIGHT))
+            {
+                ASSERT(observer->GetGuidValue(PLAYER_FARSIGHT) == _owner->GetGUID());
+                observer->SetViewpoint(_owner, false);
+            }
+
+            //Map::CanEnter and MapMgr::CanPlayerEnter are edited to not block observers
+            if (RestrictObservers(_owner) && !IsSneak(observer))
+            {
+                if (observer->GetObserversMgr()->ErrorSent == false)
+                {
+                    observer->GetObserversMgr()->ErrorSent = true;
+                    ChatHandler ch(observer->GetSession());
+                    ch.PSendSysMessage("%s is in %s which you cannot enter.",
+                        _owner->GetName().c_str(), _owner->GetMap()->GetMapName());
+                }
+
+                continue;
+            }
+
+            if (observer->GetObserversMgr()->ErrorSent == true)
+                observer->GetObserversMgr()->ErrorSent = false;
+
+            TeleportObserver(observer);
+
+            continue;
+        }
+
+        if (observer->GetGuidValue(PLAYER_FARSIGHT) != _owner->GetGUID())
+        {
+            ASSERT(observer->GetGuidValue(PLAYER_FARSIGHT) == 0);
+            observer->SetViewpoint(_owner, true);
+        }
+
+        //1) Keep close (needed for combat text to not glitch)
+        if (observer->GetDistance2d(_owner) > 15.0f)
+            observer->TeleportTo(*_owner, TELE_TO_NOT_LEAVE_COMBAT|TELE_TO_GM_MODE);
+    }
+}
+
+bool ObserversMgr::RestrictObservers(Player const* owner)
+{
+    Map const* currMap = owner->FindMap();
+
+    if (!currMap)
+        return true;
+
+    if ((!_enableObserversDungeons && currMap->IsNonRaidDungeon()) ||
+        (!_enableObserversRaids && currMap->IsRaid()) ||
+        (!_enableObserversBGs && currMap->IsBattleground()) ||
+        (!_enableObserversArenas && currMap->IsBattleArena()))
+        return true;
+
+    return false;
+}
+//invoker conditions
+bool ObserversMgr::CanAddObserver(Player* observer)
+{
+    if (!IsObserverModEnabled())
+        return false; //silent
+
+    // player himself has observers
+    //TODO: fix this properly
+    //if (observer->GetObserversMgr() && !observer->GetObserversMgr()->GetObserversMap()->empty())
+    //    return false;
+
+    if (observer->GetCharmerOrOwnerOrOwnGUID() != observer->GetGUID() ||
+        observer->GetCharmedGUID() || observer->GetMinionGUID() ||
+        observer->GetGuidValue(PLAYER_FARSIGHT) || observer->GetAI() ||
+        observer->IsInFlight() || observer->GetSession()->isLogingOut() ||
+        observer->IsBeingTeleported() || observer->IsMounted() ||
+        !observer->CanFreeMove() || observer->duel || observer->GetTransformSpell() ||
+        (observer->IsPvP() && !(observer->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_SANCTUARY)) ||
+        observer->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) ||
+        observer->IsInCombat() || !observer->IsAlive() ||
+        observer->IsUnderWater() || observer->IsMirrorTimerActive(FATIGUE_TIMER) ||
+        observer->IsMirrorTimerActive(BREATH_TIMER) || observer->IsMirrorTimerActive(FIRE_TIMER))
+        return false;
+
+    if (observer->GetCurrentSpell(CURRENT_MELEE_SPELL) ||
+        observer->GetCurrentSpell(CURRENT_GENERIC_SPELL) ||
+        observer->GetCurrentSpell(CURRENT_CHANNELED_SPELL) ||
+        observer->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+        return false;
+
+    if (observer->isMoving())
+        return false;
+
+    if (observer->GetGroup() || observer->GetGroupInvite())
+        return false;
+
+    if (observer->isUsingLfg())
+        return false;
+
+    if (observer->InBattlegroundQueue())
+        return false;
+
+    Map const* map = observer->FindMap();
+    if (!map || !map->GetEntry()->IsWorldMap())
+        return false;
+
+    return true;
+}
+
+bool ObserversMgr::IsSneak(Player const* observer)
+{
+    return _enableSneaks && observer->IsGameMaster();
+}
+
+Player* ObserversMgr::GetObserver(uint32 guidlow) const
+{
+    ObserverMap::const_iterator itr = _observers.find(guidlow);
+    return itr != _observers.end() ? itr->second : nullptr;
+}
+
+void ObserversMgr::TeleportObserver(Player* observer)
+{
+    if (!MapManager::IsValidMapCoord(*_owner))
+        return;
+
+    if (_owner->GetMap()->IsDungeon())
+    {
+        if (_owner->GetMap()->IsRaid())
+            observer->SetDungeonDifficulty(_owner->GetDungeonDifficulty());
+    }
+    observer->TeleportTo(*_owner, TELE_TO_GM_MODE);
+    observer->SetPhaseMask(_owner->GetPhaseMask(), true);
+}
+
+void ObserversMgr::OnTeleportFar()
+{
+    Player* observer;
+    ObserversMgr* mgr;
+    for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+    {
+        observer = itr->second;
+        mgr = observer->GetObserversMgr();
+
+        if (!observer->IsInWorld() || observer->IsBeingTeleported())
+            continue;
+
+        if (observer->GetGuidValue(PLAYER_FARSIGHT))
+        {
+            ASSERT(observer->GetGuidValue(PLAYER_FARSIGHT) == _owner->GetGUID());
+            observer->SetViewpoint(_owner, false);
+        }
+
+        uint32 mapId = mgr->GetOrigMapId();
+        float x,y,z,o;
+        mgr->GetOrigPos(x, y, z, o);
+        observer->TeleportTo(mapId, x, y, z, o);
+    }
+}
+
+void ObserversMgr::RemoveAllObservers()
+{
+    while (!_observers.empty())
+        RemoveObserver(_observers.begin()->first, OBSERVER_REMOVE_LOGOUT);
+}
+
+void ObserversMgr::RemoveObserver(uint32 guidlow, uint8 reason)
+{
+    ObserverMap::const_iterator itr = _observers.find(guidlow);
+    if (itr == _observers.end())
+    {
+        std::string obName;
+        sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, guidlow), obName);
+        TC_LOG_ERROR("entities.unit", "%s (%u) tried to remove observer %s (%u) which doesn't belong to his observerMgr!!",
+            _owner->GetName().c_str(), _owner->GetGUID().GetCounter(), obName.c_str(), guidlow);
+        //ASSERT(false);
+        return;
+    }
+
+    Player* observer = itr->second;
+    ObserversMgr* mgr = observer->GetObserversMgr();
+    bool sneak = IsSneak(observer);
+
+    // same/different map
+    if (observer->GetGuidValue(PLAYER_FARSIGHT))
+    {
+        ASSERT(observer->GetGuidValue(PLAYER_FARSIGHT) == _owner->GetGUID());
+        observer->SetViewpoint(_owner, false);
+    }
+
+    uint32 mapId = mgr->GetOrigMapId();
+    float x,y,z,o;
+    mgr->GetOrigPos(x, y, z, o);
+    observer->TeleportTo(mapId, x, y, z, o);
+
+    _observers.erase(itr);
+
+    ASSERT(mgr->GetAcceptor() == _owner);
+    mgr->SetAcceptor(nullptr);
+
+    observer->RemoveAurasDueToSpell(SPELL_ROOT_SELF);
+    //observer->RecalculateObjectScale();
+    observer->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+    observer->SetUInt32Value(UNIT_FIELD_DISPLAYID, mgr->OrigModelId);
+    observer->SetVisible(true);
+
+    if (!observer->GetSession()->isLogingOut())
+    {
+        ChatHandler ch(observer->GetSession());
+        std::string reasonStr = "You are no longer observing %s";
+        if (reason == OBSERVER_REMOVE_KICKED)
+            reasonStr += " (kicked)";
+        else if (reason == OBSERVER_REMOVE_LOGOUT)
+            reasonStr += " (logged out)";
+        ch.PSendSysMessage(reasonStr.c_str(), _owner->GetName().c_str());
+    }
+    if (!_owner->GetSession()->isLogingOut() && !sneak)
+    {
+        ChatHandler ch(_owner->GetSession());
+        std::string reasonStr = "%s is no longer observing you";
+        if (reason == OBSERVER_REMOVE_KICKED)
+            reasonStr += " (kicked)";
+        else if (reason == OBSERVER_REMOVE_LOGOUT)
+            reasonStr += " (logged out)";
+        ch.PSendSysMessage(reasonStr.c_str(), observer->GetName().c_str());
+    }
+}
+
+ObserverAddResult ObserversMgr::AddObserver(Player* observer)
+{
+    if (!_enableObservers)
+    {
+        ChatHandler ch(observer->GetSession());
+        ch.SendSysMessage("Observers system is currently disabled.");
+        return OBSERVER_ADD_DISABLED;
+    }
+
+    if (observer->IsObserver())
+    {
+        ChatHandler ch(observer->GetSession());
+        ch.PSendSysMessage("Cannot start observing %s while observing another player", _owner->GetName().c_str());
+        return OBSERVER_ADD_WATCHING_ANOTHER;
+    }
+    //we are observing another player - chain through
+    if (_acceptor)
+    {
+        ChatHandler ch(observer->GetSession());
+        ch.PSendSysMessage("Cannot start observing: %s is observing %s.", _owner->GetName().c_str(), _acceptor->GetName().c_str());
+        return OBSERVER_ADD_WATCHING_ANOTHER;
+    }
+
+    if (GetObserver(observer->GetGUID().GetCounter()))
+        return OBSERVER_ADD_ALREADY_HAVE; //Silent error, intended
+    if (_owner->IsBeingTeleported())
+    {
+        ChatHandler ch(observer->GetSession());
+        ch.PSendSysMessage("You cannot watch %s while he is about to teleport. Try again.", _owner->GetName().c_str());
+        return OBSERVER_ADD_BUSY;
+    }
+    if (GetObserversCountWithoutSneaks() >= GetMaxObservers())
+    {
+        ChatHandler ch(observer->GetSession());
+        ch.PSendSysMessage("%s exceeded max observers (%u).", _owner->GetName().c_str(), GetMaxObservers());
+        return OBSERVER_ADD_MAX_EXCEED;
+    }
+
+    ObserversMgr* mgr = observer->GetObserversMgr();
+    if (!mgr)
+        mgr = new ObserversMgr(observer);
+
+    _observers[observer->GetGUID().GetCounter()] = observer;
+    mgr->SetAcceptor(_owner);
+
+    //save old values
+    mgr->OrigMapId  = observer->GetMapId();
+    mgr->OrigZoneId = observer->GetZoneId();
+    observer->GetPosition(mgr->OrigX, mgr->OrigY, mgr->OrigZ, mgr->OrigO);
+
+    mgr->OrigModelId = observer->GetUInt32Value(UNIT_FIELD_DISPLAYID);
+
+    //invisible unattackable state
+    observer->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+    observer->SetVisible(false);
+    observer->SetUInt32Value(UNIT_FIELD_DISPLAYID, MODELID_INVISIBLE);
+
+    //scale
+    //observer->SetObjectScale(0.f);
+
+    //disable movement
+    if (Aura* root = observer->AddAura(SPELL_ROOT_SELF, observer))
+    {
+        root->SetDuration(20000);
+        root->SetMaxDuration(20000);
+    }
+
+    return OBSERVER_ADD_SUCCESS;
+}
+
+//UTIL
+bool ObserversMgr::IsObserverAllowed(uint32 guidlow) const
+{
+    ObserverAccessList::const_iterator itr = _accessList.find(guidlow);
+    return itr != _accessList.end() ? itr->second == OBSERVER_FLAG_ALLOWED : false;
+}
+
+bool ObserversMgr::IsObserverForbidden(uint32 guidlow) const
+{
+    ObserverAccessList::const_iterator itr = _accessList.find(guidlow);
+    return itr != _accessList.end() ? itr->second == OBSERVER_FLAG_FORBIDDEN : false;
+}
+
+bool ObserversMgr::IsObserverInQuery(uint32 guidlow) const
+{
+    ObserverAccessList::const_iterator itr = _accessList.find(guidlow);
+    return itr != _accessList.end() ? itr->second == OBSERVER_FLAG_PENDING : false;
+}
+
+void ObserversMgr::AllowObserver(uint32 guidlow)
+{
+    _accessList[guidlow] = OBSERVER_FLAG_ALLOWED;
+    if (!_needUpdate)
+        _needUpdate = true;
+}
+
+void ObserversMgr::ForbidObserver(uint32 guidlow)
+{
+    _accessList[guidlow] = OBSERVER_FLAG_FORBIDDEN;
+    if (!_needUpdate)
+        _needUpdate = true;
+}
+
+void ObserversMgr::QueryObserver(uint32 guidlow)
+{
+    _accessList[guidlow] = OBSERVER_FLAG_PENDING;
+    if (!_needUpdate)
+        _needUpdate = true;
+}
+
+uint16 ObserversMgr::GetAllowedObserversCount() const
+{
+    uint16 count = 0;
+    for (ObserverAccessList::const_iterator itr = _accessList.begin(); itr != _accessList.end(); ++itr)
+        if (itr->second == OBSERVER_FLAG_ALLOWED)
+            ++count;
+
+    return count;
+}
+
+uint16 ObserversMgr::GetForbiddenObserversCount() const
+{
+    uint16 count = 0;
+    for (ObserverAccessList::const_iterator itr = _accessList.begin(); itr != _accessList.end(); ++itr)
+        if (itr->second == OBSERVER_FLAG_FORBIDDEN)
+            ++count;
+
+    return count;
+}
+
+uint16 ObserversMgr::GetPendingObserversCount() const
+{
+    uint16 count = 0;
+    for (ObserverAccessList::const_iterator itr = _accessList.begin(); itr != _accessList.end(); ++itr)
+        if (itr->second == OBSERVER_FLAG_PENDING)
+            ++count;
+
+    return count;
+}
+
+void ObserversMgr::SetAutoAllow(bool set)
+{
+    _autoAllow = set;
+    if (set && _autoForbid) // autoallow and autoforbid conflict
+        _autoForbid = false;
+}
+
+void ObserversMgr::SetAutoForbid(bool set)
+{
+    _autoForbid = set;
+    if (set && _autoAllow) // autoallow and autoforbid conflict
+        _autoAllow = false;
+}
+
+void ObserversMgr::_unloadAccessList()
+{
+    _needUpdate = false;
+    while (!_accessList.empty())
+        _accessList.erase(_accessList.begin());
+}
+//ACCESS
+void ObserversMgr::_loadAccessList()
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT observer, flag FROM characters_observers WHERE guid = %u",
+        _owner->GetGUID().GetCounter());
+
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        do
+        {
+            _accessList[fields[0].GetUInt32()] = fields[1].GetUInt8();
+        }
+        while (result->NextRow());
+    }
+}
+
+void ObserversMgr::_storeAccessList()
+{
+    for (ObserverAccessList::const_iterator itr = _accessList.begin(); itr != _accessList.end(); ++itr)
+    {
+        //ASYNC
+        CharacterDatabase.PExecute("REPLACE INTO characters_observers (guid, observer, flag) VALUES (%u, %u, %u)",
+            _owner->GetGUID().GetCounter(), itr->first, itr->second);
+    }
+}
+//PACKETS
+void ObserversMgr::SendToObservers(WorldPacket* packet)
+{
+    //copy packet
+    WorldPacket data = WorldPacket(*packet);
+    for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+        if (itr->second->IsInWorld())
+            itr->second->GetSession()->SendPacket(&data);
+}
+
+void ObserversMgr::SendToObservers(uint16 opcode, void* uniData1, void* uniData2, void* uniData3)
+{
+    if (_observers.empty())
+        return;
+
+    // Notes:
+    // SendSpellDamageResist (SMSG_PROCRESIST) - Unused
+
+    switch (opcode)
+    {
+        case SMSG_SPELLORDAMAGE_IMMUNE:
+        {
+            if (_sendPacketsCombat == false)
+                break;
+
+            Unit* target = (Unit*)uniData1;
+            uint32 spellId = *((uint32*)uniData2);
+
+            for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+            {
+                if (!itr->second->IsInWorld())
+                    continue;
+
+                // Copied from Unit::SendSpellDamageImmune
+                WorldPacket data(SMSG_SPELLORDAMAGE_IMMUNE, (8+8+4+1));
+                data << uint64(itr->second->GetGUID());
+                data << uint64(target->GetGUID());
+                data << uint32(spellId);
+                data << uint8(0); // bool - log format: 0-default, 1-debug
+
+                itr->second->GetSession()->SendPacket(&data);
+            }
+
+            break;
+        }
+        case SMSG_SPELLLOGMISS:
+        {
+            if (_sendPacketsCombat == false)
+                break;
+
+            Unit* target = (Unit*)uniData1;
+            uint32 spellId = *((uint32*)uniData2);
+            SpellMissInfo missInfo = *((SpellMissInfo*)uniData3);
+
+            for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+            {
+                if (!itr->second->IsInWorld())
+                    continue;
+
+                // Copied from Unit::SendSpellMiss
+                WorldPacket data(SMSG_SPELLLOGMISS, (4+8+1+4+8+1));
+                data << uint32(spellId);
+                data << uint64(itr->second->GetGUID());
+                data << uint8(0);                                       // can be 0 or 1
+                data << uint32(1);                                      // target count
+                data << uint64(target->GetGUID());                      // target GUID
+                data << uint8(missInfo);
+
+                itr->second->GetSession()->SendPacket(&data);
+            }
+
+            break;
+        }
+        case SMSG_PERIODICAURALOG:
+        {
+            if (_sendPacketsCombat == false)
+                break;
+
+            SpellPeriodicAuraLogInfo* pInfo = (SpellPeriodicAuraLogInfo*)uniData1;
+            Unit* target = (Unit*)uniData2;
+            AuraEffect const* aura = pInfo->auraEff;
+
+            for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+            {
+                if (!itr->second->IsInWorld())
+                    continue;
+
+                // Moved from Unit::SendPeriodicAuraLog
+                WorldPacket data(SMSG_PERIODICAURALOG, 30);
+                data << target->GetPackGUID();
+                data << itr->second->GetGUID().WriteAsPacked();
+                data << uint32(aura->GetId());                          // spellId
+                data << uint32(1);                                      // count
+                data << uint32(aura->GetAuraType());                    // auraId
+                switch (aura->GetAuraType())
+                {
+                    case SPELL_AURA_PERIODIC_DAMAGE:
+                    case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
+                        data << uint32(pInfo->damage);                  // damage
+                        data << uint32(pInfo->overDamage);              // overkill?
+                        data << uint32(aura->GetSpellInfo()->GetSchoolMask());
+                        data << uint32(pInfo->absorb);                  // absorb
+                        data << uint32(pInfo->resist);                  // resist
+                        data << uint8(pInfo->critical);                 // new 3.1.2 critical tick
+                        break;
+                    default:
+                        return;
+                }
+
+                itr->second->GetSession()->SendPacket(&data);
+            }
+
+            break;
+        }
+        case SMSG_SPELLNONMELEEDAMAGELOG:
+        {
+            if (_sendPacketsCombat == false)
+                break;
+
+            //copy CalcDamageInfo
+            SpellNonMeleeDamage log = *(SpellNonMeleeDamage*)uniData1;
+            //TC_LOG_ERROR("entities.unit", "ObsMgr::SMSG_SPELLNONMELEEDAMAGELOG: attacker: %u, damage = %u (%u)",
+            //    log->attacker->GetGUID().GetCounter(), log->damage, log->cleanDamage);
+            for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+            {
+                if (!itr->second->IsInWorld())
+                    continue;
+
+                log.attacker = itr->second; // !!Send with observer as attacker!!
+
+                // Copied from Unit::SendSpellNonMeleeDamageLog
+                WorldPacket data(SMSG_SPELLNONMELEEDAMAGELOG, (16+4+4+4+1+4+4+1+1+4+4+1)); // we guess size
+                data << log.target->GetPackGUID();
+                data << log.attacker->GetPackGUID();
+                data << uint32(log.SpellID);
+                data << uint32(log.damage);                            // damage amount
+                int32 overkill = log.damage - log.target->GetHealth();
+                data << uint32(overkill > 0 ? overkill : 0);            // overkill
+                data << uint8 (log.schoolMask);                        // damage school
+                data << uint32(log.absorb);                            // AbsorbedDamage
+                data << uint32(log.resist);                            // resist
+                data << uint8 (log.periodicLog);                       // bool: show and log spell name
+                data << uint8 (log.unused);                            // unused
+                data << uint32(log.blocked);                           // blocked
+                data << uint32(log.HitInfo);
+                data << uint8 (log.HitInfo & (SPELL_HIT_TYPE_CRIT_DEBUG | SPELL_HIT_TYPE_HIT_DEBUG | SPELL_HIT_TYPE_ATTACK_TABLE_DEBUG));
+
+                itr->second->GetSession()->SendPacket(&data);
+            }
+
+            break;
+        }
+        case SMSG_SPELLHEALLOG:
+        {
+            if (_sendPacketsCombat == false)
+                break;
+
+            //copy HealInfo
+            HealInfo healInfo = *(HealInfo*)uniData1;
+            bool critical = *(bool*)uniData2;
+            //TC_LOG_ERROR("entities.unit", "ObsMgr::SMSG_SPELLHEALLOG);
+            for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+            {
+                if (!itr->second->IsInWorld())
+                    continue;
+
+                WorldPacket data(SMSG_SPELLHEALLOG, 8+8+4+4+4+4+1+1);
+                data << healInfo.GetTarget()->GetPackGUID();
+                data << itr->second->GetPackGUID(); //observer as source
+                data << uint32(healInfo.GetSpellInfo()->Id);
+                data << uint32(healInfo.GetHeal());
+                data << uint32(healInfo.GetHeal() - healInfo.GetEffectiveHeal());
+                data << uint32(healInfo.GetAbsorb());
+                data << uint8(critical ? 1 : 0);
+                data << uint8(0); //unused
+
+                itr->second->GetSession()->SendPacket(&data);
+            }
+
+            break;
+        }
+        case SMSG_ATTACKERSTATEUPDATE:
+        {
+            if (_sendPacketsCombat == false)
+                break;
+
+            //copy CalcDamageInfo
+            CalcDamageInfo damageInfo = *((CalcDamageInfo*)uniData1);
+            //TC_LOG_ERROR("entities.unit", "ObsMgr::SMSG_ATTACKERSTATEUPDATE: attacker: %u, damage = %u (%u)",
+            //    damageInfo->attacker->GetGUID().GetCounter(), damageInfo->damage, damageInfo->cleanDamage);
+
+            uint8 count = 1;
+            if (damageInfo.Damages[1].Damage || damageInfo.Damages[1].Absorb || damageInfo.Damages[1].Resist)
+                ++count;
+            for (ObserverMap::const_iterator itr = _observers.begin(); itr != _observers.end(); ++itr)
+            {
+                if (!itr->second->IsInWorld())
+                    continue;
+
+                damageInfo.Attacker = itr->second; // !!Send with observer as attacker!!
+
+                // Copied from Unit::SendAttackStateUpdate
+                WorldPacket data(SMSG_ATTACKERSTATEUPDATE, (4+5+5+4+4+1+(4+4+4)*2+4*2+4*2+1+4+4+4+4+4*12));
+
+                data << uint32(damageInfo.HitInfo);
+                data << damageInfo.Attacker->GetPackGUID();
+                data << damageInfo.Target->GetPackGUID();
+                data << uint32(damageInfo.Damages[0].Damage + damageInfo.Damages[1].Damage); // Full damage
+                int32 overkill = damageInfo.Damages[0].Damage + damageInfo.Damages[1].Damage - damageInfo.Target->GetHealth();
+                data << uint32(overkill < 0 ? 0 : overkill);            // Overkill
+                data << uint8(count);                                   // Sub damage count
+
+                for (uint8 i = 0; i != count; ++i)
+                {
+                    data << uint32(damageInfo.Damages[i].DamageSchoolMask);       // School of sub damage
+                    data << float(damageInfo.Damages[i].Damage);                  // sub damage
+                    data << uint32(damageInfo.Damages[i].Damage);                 // Sub Damage
+                }
+
+                if (damageInfo.HitInfo & (HITINFO_FULL_ABSORB | HITINFO_PARTIAL_ABSORB))
+                {
+                    for (uint8 i = 0; i != count; ++i)
+                        data << uint32(damageInfo.Damages[i].Absorb);             // Absorb
+                }
+
+                if (damageInfo.HitInfo & (HITINFO_FULL_RESIST | HITINFO_PARTIAL_RESIST))
+                {
+                    for (uint8 i = 0; i != count; ++i)
+                        data << uint32(damageInfo.Damages[i].Resist);             // Resist
+                }
+
+                data << uint8(damageInfo.TargetState);
+                data << uint32(0);  // Unknown attackerstate
+                data << uint32(0);  // Melee spellid
+
+                if (damageInfo.HitInfo & HITINFO_BLOCK)
+                    data << uint32(damageInfo.Blocked);
+
+                if (damageInfo.HitInfo & HITINFO_RAGE_GAIN)
+                    data << uint32(0);
+
+                //! Probably used for debugging purposes, as it is not known to appear on retail servers
+                if (damageInfo.HitInfo & HITINFO_UNK1)
+                {
+                    data << uint32(0);
+                    data << float(0);
+                    data << float(0);
+                    data << float(0);
+                    data << float(0);
+                    data << float(0);
+                    data << float(0);
+                    data << float(0);
+                    data << float(0);
+                    data << float(0);       // Found in a loop with 1 iteration
+                    data << float(0);       // ditto ^
+                    data << uint32(0);
+                }
+
+                itr->second->GetSession()->SendPacket(&data);
+            }
+
+            break;
+        }
+        default:
+            break;
+    }
+}
diff --git a/src/server/game/Observers/ObserversMgr.h b/src/server/game/Observers/ObserversMgr.h
new file mode 100644
index 0000000..b410515
--- /dev/null
+++ b/src/server/game/Observers/ObserversMgr.h
@@ -0,0 +1,137 @@
+#ifndef _OBSERVERSMGR_H
+#define _OBSERVERSMGR_H
+
+#include "Common.h"
+
+/*
+Observers system by Trickerer <onlysuffering@gmail.com>
+*/
+
+class Player;
+
+enum ObserverAddResult
+{
+    OBSERVER_ADD_DISABLED                   = 0x001,
+    OBSERVER_ADD_ALREADY_HAVE               = 0x002,
+    OBSERVER_ADD_MAX_EXCEED                 = 0x004,
+    OBSERVER_ADD_INSTANCE_LIMIT             = 0x008,
+    OBSERVER_ADD_BUSY                       = 0x010,
+    OBSERVER_ADD_WATCHING_ANOTHER           = 0x020,
+
+    OBSERVER_ADD_SUCCESS                    = 0x100
+};
+
+enum ObserverRemoveReason : uint8
+{
+    OBSERVER_REMOVE_SELF                    = 1,
+    OBSERVER_REMOVE_KICKED                  = 2,
+    OBSERVER_REMOVE_LOGOUT                  = 3,
+    OBSERVER_REMOVE_SWITCH                  = 4
+};
+
+enum ObserverFlags : uint8
+{
+    OBSERVER_FLAG_ALLOWED                   = 1,
+    OBSERVER_FLAG_FORBIDDEN                 = 2,
+    OBSERVER_FLAG_PENDING                   = 3
+};
+
+typedef std::unordered_map<uint32 /*guidlow*/, Player* /*observer*/> ObserverMap;
+typedef std::unordered_map<uint32 /*guidlow*/, uint8 /*flag*/> ObserverAccessList;
+
+class ObserversMgr
+{
+    public:
+        ObserversMgr(Player* const observed);
+        ~ObserversMgr();
+
+        static bool IsObserverModEnabled();
+        static bool SneaksEnabled();
+        //static bool SendCombatPackets();
+        static bool SendItemPackets();
+
+        static void ReloadConfig() { LoadConfig(true); }
+        static void LoadConfig(bool force = false);
+
+        //owner part
+        Player* GetOwner() const { return _owner; }
+        ObserverMap const* GetObserversMap() const { return &_observers; }
+        //ObserverMap* GetObserversMap() { return &_observers; }
+
+        void UpdateMap(uint32 diff);
+
+        Player* GetObserver(uint32 guidlow) const;
+        //bool HasObservers() const { return !_observers.empty(); }
+        uint16 GetObserversCount() const { return _observers.size(); }
+        uint16 GetObserversCountWithoutSneaks() const;
+        static uint16 GetMaxObservers(); //not owner part
+        static bool RestrictObservers(Player const* owner); //not owner part
+        static bool CanAddObserver(Player* observer); //not owner part
+        static bool IsSneak(Player const* observer); //not owner part
+
+        void TeleportObserver(Player* observer);
+
+        void OnTeleportFar();
+
+        void RemoveAllObservers();
+        void RemoveObserver(uint32 guidlow, uint8 reason);
+        ObserverAddResult AddObserver(Player* observer);
+
+        ObserverAccessList const* GetAccessList() const { return &_accessList; }
+        //ObserverAccessList* GetAccessList() { return &_accessList; }
+
+        bool IsObserverAllowed(uint32 guidlow) const;
+        bool IsObserverForbidden(uint32 guidlow) const;
+        bool IsObserverInQuery(uint32 guidlow) const;
+        void AllowObserver(uint32 guidlow);
+        void ForbidObserver(uint32 guidlow);
+        void QueryObserver(uint32 guidlow);
+
+        uint16 GetAllowedObserversCount() const;
+        uint16 GetForbiddenObserversCount() const;
+        uint16 GetPendingObserversCount() const;
+
+        bool IsAutoAllow() const { return _autoAllow; }
+        bool IsAutoForbid() const { return _autoForbid; }
+        void SetAutoAllow(bool set);
+        void SetAutoForbid(bool set);
+
+        void SendToObservers(WorldPacket* packet);
+        void SendToObservers(uint16 opcode, void* uniData1, void* uniData2 = NULL, void* uniData3 = NULL);
+
+        //observer part
+        Player* GetAcceptor() const { return _acceptor; }
+        void SetAcceptor(Player* acceptor) { _acceptor = acceptor; }
+        //saved values retrieve
+        uint32 GetOrigMapId() const { return OrigMapId; }
+        uint32 GetOrigZoneId() const { return OrigZoneId; }
+        void GetOrigPos(float &x, float& y, float &z, float &o)
+        { x = OrigX; y = OrigY; z = OrigZ; o = OrigO; }
+
+    protected:
+        uint32 OrigModelId;
+        uint32 OrigMapId;
+        uint32 OrigZoneId;
+        float OrigX, OrigY, OrigZ, OrigO;
+
+        bool ErrorSent;
+
+    private:
+        void _unloadAccessList();
+        void _loadAccessList();
+        void _storeAccessList();
+
+        Player* const _owner;
+        Player* _acceptor;
+        ObserverMap _observers;
+        ObserverAccessList _accessList;
+
+        bool _sneakPeak;
+        bool _needUpdate;
+        bool _autoAllow;
+        bool _autoForbid;
+
+        uint32 _rootTimer;
+};
+
+#endif
diff --git a/src/server/game/Spells/Auras/SpellAuras.cpp b/src/server/game/Spells/Auras/SpellAuras.cpp
index 94dc12f..0098d76 100644
--- a/src/server/game/Spells/Auras/SpellAuras.cpp
+++ b/src/server/game/Spells/Auras/SpellAuras.cpp
@@ -2647,6 +2647,11 @@ void UnitAura::FillTargetMap(std::unordered_map<Unit*, uint8>& targets, Unit* ca
         if (GetUnitOwner()->HasUnitState(UNIT_STATE_ISOLATED))
             continue;
 
+        // Observers: Observers are isolated
+        if (caster->GetTypeId() == TYPEID_PLAYER && caster->ToPlayer()->IsObserver())
+            continue;
+        // End Observers
+
         std::vector<Unit*> units;
         ConditionContainer* condList = m_spellInfo->Effects[effIndex].ImplicitTargetConditions;
 
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index b95ede0..b52cedd 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -5038,6 +5038,11 @@ void Spell::HandleEffects(Unit* pUnitTarget, Item* pItemTarget, GameObject* pGOT
 
 SpellCastResult Spell::CheckCast(bool strict, uint32* param1 /*= nullptr*/, uint32* param2 /*= nullptr*/)
 {
+    // Observers: deny spells for observers
+    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->ToPlayer()->IsObserver())
+        return SPELL_FAILED_DONT_REPORT;
+    // End Observers
+
     // check death state
     if (m_caster->ToUnit() && !m_caster->ToUnit()->IsAlive() && !m_spellInfo->IsPassive() && !(m_spellInfo->HasAttribute(SPELL_ATTR0_CASTABLE_WHILE_DEAD) || (IsTriggered() && !m_triggeredByAuraSpell)))
         return SPELL_FAILED_CASTER_DEAD;
diff --git a/src/server/scripts/Custom/Observers/ObserversCS.cpp b/src/server/scripts/Custom/Observers/ObserversCS.cpp
new file mode 100644
index 0000000..770d40e
--- /dev/null
+++ b/src/server/scripts/Custom/Observers/ObserversCS.cpp
@@ -0,0 +1,810 @@
+#include "ObserversMgr.h"
+#include "CharacterCache.h"
+#include "Chat.h"
+#include "DBCStores.h"
+#include "Language.h"
+#include "Log.h"
+#include "Player.h"
+#include "RBAC.h"
+#include "ScriptMgr.h"
+#include "World.h"
+#include "WorldSession.h"
+
+/*
+Observers system by Trickerer <onlysuffering@gmail.com>
+Name: script_observer_commands
+%Complete: 70 maybe
+Comment: Observers related commands
+Category: commandscripts
+*/
+
+#define GM_COMMANDS rbac::RBACPermissions(197)
+#define PLAYER_COMMANDS rbac::RBACPermissions(195)
+
+static int32 currModel = 11187; //last checked
+
+class script_observers_commands : public CommandScript
+{
+public:
+    script_observers_commands() : CommandScript("script_observers_commands") { }
+
+    std::vector<ChatCommand> GetCommands() const override
+    {
+        static std::vector<ChatCommand> observersAllowCommandTable =
+        {
+            { "all",        PLAYER_COMMANDS,                false, &HandleObserversAllowAllCommand,         "" },
+            { "auto",       PLAYER_COMMANDS,                false, &HandleObserversAllowAutoCommand,        "" },
+            { "",           PLAYER_COMMANDS,                false, &HandleObserversAllowCommand,            "" },
+        };
+
+        static std::vector<ChatCommand> observersForbidCommandTable =
+        {
+            { "all",        PLAYER_COMMANDS,                false, &HandleObserversForbidAllCommand,        "" },
+            { "auto",       PLAYER_COMMANDS,                false, &HandleObserversForbidAutoCommand,       "" },
+            { "",           PLAYER_COMMANDS,                false, &HandleObserversForbidCommand,           "" },
+        };
+
+        static std::vector<ChatCommand> observersKickCommandTable =
+        {
+            { "all",        PLAYER_COMMANDS,                false, &HandleObserversKickAllCommand,          "" },
+            { "",           PLAYER_COMMANDS,                false, &HandleObserversKickCommand,             "" },
+        };
+
+        static std::vector<ChatCommand> observersListCommandTable =
+        {
+            { "active",     PLAYER_COMMANDS,                false, &HandleObserversListActiveCommand,       "" },
+            { "allowed",    PLAYER_COMMANDS,                false, &HandleObserversListAllowedCommand,      "" },
+            { "forbidden",  PLAYER_COMMANDS,                false, &HandleObserversListForbiddenCommand,    "" },
+            { "pending",    PLAYER_COMMANDS,                false, &HandleObserversListPendingCommand,      "" },
+            { "all",        GM_COMMANDS,                    false, &HandleObserversListAllCommand,          "" },
+        };
+
+        static std::vector<ChatCommand> observersDebugCommandTable =
+        {
+            { "set",        GM_COMMANDS,                    false, &HandleObserversDebugSetCommand,       "" },
+            { "continue",   GM_COMMANDS,                    false, &HandleObserversDebugContinueCommand,      "" },
+        };
+
+        static std::vector<ChatCommand> observersCommandTable =
+        {
+            { "allow",      PLAYER_COMMANDS,                false, nullptr,              "", observersAllowCommandTable },
+            { "forbid",     PLAYER_COMMANDS,                false, nullptr,             "", observersForbidCommandTable },
+            { "kick",       PLAYER_COMMANDS,                false, nullptr,               "", observersKickCommandTable },
+            { "list",       PLAYER_COMMANDS,                false, nullptr,               "", observersListCommandTable },
+            { "debug",      GM_COMMANDS,                    false, nullptr,               "", observersDebugCommandTable },
+            { "reloadcfg",  GM_COMMANDS,                    true,  &HandleObserversReloadCfgCommand,        "" },
+        };
+
+        static std::vector<ChatCommand> commandTable =
+        {
+            { "observers",  PLAYER_COMMANDS,                false, nullptr,                   "", observersCommandTable },
+            { "observe",    PLAYER_COMMANDS,                false, HandleObserveCommand,                    "" },
+            { "deobserve",  PLAYER_COMMANDS,                false, HandleDeObserveCommand,                  "" },
+        };
+        return commandTable;
+    }
+
+    static bool HandleObserversDebugSetCommand(ChatHandler* handler, const char* args)
+    {
+        int32 val = (int32)atoi((char*)args);
+        currModel = val;
+        handler->PSendSysMessage("Curr set to %i", val);
+        return true;
+    }
+    static bool HandleObserversDebugContinueCommand(ChatHandler* handler, const char* args)
+    {
+        handler->GetSession()->GetPlayer()->SetDisplayId(uint32(currModel++));
+        if (!(currModel % 100))
+            handler->PSendSysMessage("Passing %i", currModel);
+        return true;
+    }
+
+    static bool HandleObserveCommand(ChatHandler* handler, const char* args)
+    {
+        handler->SetSentErrorMessage(true);
+
+        if (!*args)
+        {
+            handler->SendSysMessage("Syntax: .observe #name");
+            handler->SendSysMessage("Enables observation of character #name");
+            return false;
+        }
+
+        ObserversMgr::LoadConfig();
+
+        if (!ObserversMgr::IsObserverModEnabled())
+            return false; //silent
+
+        Player* observer = handler->GetSession()->GetPlayer();
+
+        if (!ObserversMgr::CanAddObserver(observer))
+        {
+            //TODO: change to errorType and add error-based output
+            handler->SendSysMessage("Cannot observe right now");
+            return false;
+        }
+
+        Player* target;
+        ObjectGuid targetGuid;
+        std::string targetName;
+        if (!handler->extractPlayerTarget((char*)args, &target, &targetGuid, &targetName))
+        {
+            handler->PSendSysMessage("Target %s not found", (char*)args);
+            return false;
+        }
+
+        if (!target)
+        {
+            if (targetName.length() > 0)
+            {
+                handler->PSendSysMessage("Cannot observe %s: player offline", targetName.c_str());
+                return false;
+            }
+
+            handler->SendSysMessage("No target");
+            return false;
+        }
+
+        if (target == observer || targetGuid == observer->GetGUID())
+        {
+            handler->SendSysMessage("Cannot use on self");
+            return false;
+        }
+
+        //if (target->IsBeingTeleported())
+        //{
+        //    handler->SendSysMessage("You are not safe to do this");
+        //    return false;
+        //}
+
+        if (handler->HasLowerSecurity(target, ObjectGuid::Empty))
+        {
+            //handler->SendSysMessage("Wrong target (1)");
+            handler->PSendSysMessage("Cannot observe %s: player offline.", target->GetName().c_str());
+            return false;
+        }
+
+        ////faction_interaction_group
+        //if (observer->GetTeam() != target->GetTeam() &&
+        //    ((observer->GetGroup() || target->GetGroup()) &&
+        //    observer->GetGroup() != target->GetGroup())
+        //    )
+        //{
+        //    handler->SendSysMessage("Wrong target (2)");
+        //    return false;
+        //}
+
+        //if (!observer->GetSocial()->HasFriend(target->GetGUID().GetCounter()))
+        //{
+        //    handler->SendSysMessage("Wrong target (3)");
+        //    return false;
+        //}
+
+        ObserversMgr* mgr = target->GetObserversMgr();
+        if (!mgr)
+            mgr = new ObserversMgr(target);
+
+        if (!(ObserversMgr::SneaksEnabled() && observer->IsGameMaster())) // is sneak
+        {
+            if (mgr->IsObserverForbidden(observer->GetGUID().GetCounter()))
+            {
+                //bahnned
+                handler->PSendSysMessage("Cannot observe %s: forbidden.", target->GetName().c_str());
+                return false;
+            }
+
+            if (mgr->IsObserverInQuery(observer->GetGUID().GetCounter()))
+            {
+                //pending
+                handler->PSendSysMessage("Cannot observe %s yet: still pending.", target->GetName().c_str());
+                return false;
+            }
+            else if (!mgr->IsObserverAllowed(observer->GetGUID().GetCounter()))
+            {
+                //first time
+                mgr->QueryObserver(observer->GetGUID().GetCounter());
+                handler->PSendSysMessage("Cannot observe %s: not in access list. Pending...", target->GetName().c_str());
+                //announce to acceptor (target)
+                ChatHandler ch(target->GetSession());
+                std::string plLink;
+                //color
+                switch (observer->GetClass())
+                {
+                    case CLASS_WARRIOR:         plLink = "|cffc79c6e|"; break;
+                    case CLASS_PALADIN:         plLink = "|cfff58cba|"; break;
+                    case CLASS_HUNTER:          plLink = "|cffabd473|"; break;
+                    case CLASS_ROGUE:           plLink = "|cfffff569|"; break;
+                    case CLASS_PRIEST:          plLink = "|cffffffff|"; break;
+                    case CLASS_DEATH_KNIGHT:    plLink = "|cffc41f3b|"; break;
+                    case CLASS_SHAMAN:          plLink = "|cff0070de|"; break;
+                    case CLASS_MAGE:            plLink = "|cff69ccf0|"; break;
+                    case CLASS_WARLOCK:         plLink = "|cff9482c9|"; break;
+                    case CLASS_DRUID:           plLink = "|cffff7d0a|"; break;
+                    default:                    plLink = "|cffffffff|"; break;
+                }
+                plLink += "Hplayer:"+observer->GetName()+"|h["+observer->GetName()+"]|h|r";
+                uint8 loc = handler->GetSessionDbcLocale();
+                ch.PSendSysMessage("New pending observer: %s: %s %s %s (level %u)", plLink.c_str(),
+                    observer->GetGender() == GENDER_MALE ? ch.GetTrinityString(LANG_CHARACTER_GENDER_MALE) : ch.GetTrinityString(LANG_CHARACTER_GENDER_FEMALE),
+                    GetRaceName(observer->GetRace(), loc), GetClassName(observer->GetClass(), loc), (uint32)observer->GetLevel());
+
+                return false;
+            }
+        }
+
+        //ALLOWED
+        ObserverAddResult result = mgr->AddObserver(observer);
+        if (result != OBSERVER_ADD_SUCCESS)
+        {
+            //if (result != OBSERVER_ADD_ALREADY_HAVE)
+            //    handler->PSendSysMessage("Failed to start observing %s, result = %u", targetName.c_str(), (uint32)result);
+            return false;
+        }
+
+        //Remove current observers and notify them
+        ObserversMgr* mymgr = observer->GetObserversMgr();
+        if (mymgr)
+        {
+            ObserverMap const observeMap = *mymgr->GetObserversMap(); //copy
+            for (ObserverMap::const_iterator itr = observeMap.begin(); itr != observeMap.end(); ++itr)
+            {
+                //if (ObserversMgr::IsSneak(itr->second))
+                //    continue;
+
+                ChatHandler och(itr->second->GetSession());
+                och.PSendSysMessage("%s switched to observe %s", observer->GetName().c_str(), target->GetName().c_str());
+                if (!ObserversMgr::IsSneak(itr->second))
+                    mymgr->RemoveObserver(itr->first, OBSERVER_REMOVE_SWITCH);
+            }
+        }
+
+        ChatHandler tHandler(target->GetSession());
+        if (!ObserversMgr::IsSneak(observer))
+        {
+            if (mgr->GetObserversCountWithoutSneaks() == 1)
+                tHandler.PSendSysMessage("You now have observer %s.", observer->GetName().c_str());
+            else
+                tHandler.PSendSysMessage("New observer %s, up to %u", observer->GetName().c_str(), (uint32)mgr->GetObserversCountWithoutSneaks());
+        }
+
+        handler->PSendSysMessage("Starting observing %s", handler->playerLink(observer->GetObserversMgr()->GetAcceptor()->GetName()).c_str());
+        return true;
+    }
+
+    static bool HandleDeObserveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+
+        Player* observer = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = observer->GetObserversMgr(); //always exists
+
+        Player* acceptor = mgr ? mgr->GetAcceptor() : nullptr;
+        ObserversMgr* amgr = acceptor ? acceptor->GetObserversMgr() : nullptr;
+        if (!mgr || !acceptor || !amgr || !amgr->GetObserver(observer->GetGUID().GetCounter()))
+        {
+            handler->SendSysMessage("Syntax: .deobserve");
+            handler->SendSysMessage("Stops observation of currently viewed character");
+            return false;
+        }
+
+        amgr->RemoveObserver(observer->GetGUID().GetCounter(), OBSERVER_REMOVE_SELF);
+
+        return true;
+    }
+
+    static bool HandleObserversAllowCommand(ChatHandler* handler, const char* args)
+    {
+        handler->SetSentErrorMessage(true);
+
+        if (!*args)
+        {
+            handler->SendSysMessage("Syntax: .observers allow #[ name | all | auto #[ on | off ] ]");
+            handler->SendSysMessage("Allows pending player to observe you");
+            return false;
+        }
+
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        Player* observer;
+        ObjectGuid observerGuid;
+        std::string observerName;
+        if (!handler->extractPlayerTarget((char*)args, &observer, &observerGuid, &observerName))
+        {
+            handler->PSendSysMessage("Player %s not found", (char*)args);
+            return false;
+        }
+
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr)
+            mgr = new ObserversMgr(owner);
+
+        if (mgr->IsObserverAllowed(observerGuid.GetCounter()))
+        {
+            handler->PSendSysMessage("Observer %s is already allowed", observerName.c_str());
+            return true;
+        }
+
+        mgr->AllowObserver(observerGuid.GetCounter());
+        handler->PSendSysMessage("Allowed observer %s", observerName.c_str());
+        if (observer)
+        {
+            ChatHandler ch(observer->GetSession());
+            ch.PSendSysMessage("You are now allowed to observe %s", owner->GetName().c_str());
+        }
+        return true;
+    }
+
+    static bool HandleObserversAllowAllCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr || mgr->GetPendingObserversCount() == 0)
+        {
+            handler->SendSysMessage("Syntax: .observers allow all");
+            handler->SendSysMessage("Allows all pending players to observe you");
+            handler->SendSysMessage("There are no pending observers right now.");
+            return false;
+        }
+
+        ObserverAccessList const* observeList = mgr->GetAccessList();
+        Player* observer;
+        ObjectGuid observerGuid;
+        std::string obName;
+        for (ObserverAccessList::const_iterator itr = observeList->begin(); itr != observeList->end(); ++itr)
+        {
+            if (itr->second == OBSERVER_FLAG_PENDING)
+            {
+                mgr->AllowObserver(itr->first);
+                if (sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, itr->first), obName))
+                {
+                    if (handler->extractPlayerTarget((char*)obName.c_str(), &observer, &observerGuid, &obName))
+                    {
+                        handler->PSendSysMessage("Allowed observer %s", obName.c_str());
+                        if (observer)
+                        {
+                            ChatHandler ch(observer->GetSession());
+                            ch.PSendSysMessage("You are now allowed to observe %s", owner->GetName().c_str());
+                        }
+                    }
+                    else
+                        handler->PSendSysMessage("Allowed observer unknown (%u)", itr->first);
+                }
+                else
+                    handler->PSendSysMessage("Allowed observer unknown (%u)", itr->first);
+            }
+        }
+
+        return true;
+    }
+
+    static bool HandleObserversAllowAutoCommand(ChatHandler* handler, const char* args)
+    {
+        handler->SetSentErrorMessage(true);
+
+        if (!*args)
+        {
+            handler->SendSysMessage("Syntax: .observers allow auto #[ on | off ]");
+            handler->SendSysMessage("Automatically allows all pending observers");
+            return false;
+        }
+
+        char* strFlag = strtok((char*)args, " ");
+        uint8 flag = !strcmp(strFlag, "on") ? 1 : !strcmp(strFlag, "off") ? 2 : 0;
+        if (!flag)
+        {
+            handler->SetSentErrorMessage(false); //send error
+            return false;
+        }
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr)
+            mgr = new ObserversMgr(owner);
+
+        mgr->SetAutoAllow(flag == 1 ? true : false);
+        handler->PSendSysMessage("Autoallow is %s", flag == 1 ? "enabled" : "disabled");
+        return true;
+    }
+
+    static bool HandleObserversForbidCommand(ChatHandler* handler, const char* args)
+    {
+        handler->SetSentErrorMessage(true);
+
+        if (!*args)
+        {
+            handler->SendSysMessage("Syntax: .observers forbid #[ name | all | auto #[ on | off ] ]");
+            handler->SendSysMessage("Kicks and bans player #name from observing you");
+            return false;
+        }
+
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        Player* observer;
+        ObjectGuid observerGuid;
+        std::string observerName;
+        if (!handler->extractPlayerTarget((char*)args, &observer, &observerGuid, &observerName))
+        {
+            //handler->PSendSysMessage("Player %s not found", (char*)args);
+            return false;
+        }
+
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr)
+            mgr = new ObserversMgr(owner);
+
+        if (mgr->GetObserver(observerGuid.GetCounter()))
+            mgr->RemoveObserver(observerGuid.GetCounter(), OBSERVER_REMOVE_KICKED);
+        if (mgr->IsObserverForbidden(observerGuid.GetCounter()))
+        {
+            handler->PSendSysMessage("Observer %s is already forbidden", observerName.c_str());
+            return true;
+        }
+        mgr->ForbidObserver(observerGuid.GetCounter());
+        handler->PSendSysMessage("Observer %s has been forbidden", observerName.c_str());
+        //no output for observer
+        return true;
+    }
+
+    static bool HandleObserversForbidAllCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr || mgr->GetPendingObserversCount() == 0)
+        {
+            handler->SendSysMessage("Syntax: .observers forbid all");
+            handler->SendSysMessage("Kicks and bans all observers");
+            return false;
+        }
+
+        ObserverAccessList const* observeList = mgr->GetAccessList();
+        Player* observer;
+        ObjectGuid observerGuid;
+        std::string obName;
+        for (ObserverAccessList::const_iterator itr = observeList->begin(); itr != observeList->end(); ++itr)
+        {
+            //if (mgr->GetObserver(itr->first))
+            //    mgr->RemoveObserver(itr->first, OBSERVER_REMOVE_KICKED);
+            if (itr->second == OBSERVER_FLAG_PENDING)
+            {
+                mgr->ForbidObserver(itr->first);
+                if (sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, itr->first), obName))
+                {
+                    if (handler->extractPlayerTarget((char*)obName.c_str(), &observer, &observerGuid, &obName))
+                    {
+                        handler->PSendSysMessage("Forbidden observer %s", obName.c_str());
+                        if (observer)
+                        {
+                            ChatHandler ch(observer->GetSession());
+                            ch.PSendSysMessage("You are now forbidden to observe %s", owner->GetName().c_str());
+                        }
+                    }
+                    else
+                        handler->PSendSysMessage("Forbidden observer unknown (%u)", itr->first);
+                }
+                else
+                    handler->PSendSysMessage("Forbidden observer unknown (%u)", itr->first);
+            }
+        }
+
+        return true;
+    }
+
+    static bool HandleObserversForbidAutoCommand(ChatHandler* handler, const char* args)
+    {
+        handler->SetSentErrorMessage(true);
+
+        if (!*args)
+        {
+            handler->SendSysMessage("Syntax: .observers forbid auto #[ on | off ]");
+            handler->SendSysMessage("Automatically forbids all pending observers");
+            return false;
+        }
+
+        char* strFlag = strtok((char*)args, " ");
+        uint8 flag = !strcmp(strFlag, "on") ? 1 : !strcmp(strFlag, "off") ? 2 : 0;
+        if (!flag)
+        {
+            handler->SetSentErrorMessage(false); //send error
+            return false;
+        }
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr)
+            mgr = new ObserversMgr(owner);
+
+        mgr->SetAutoForbid(flag == 1 ? true : false);
+        handler->PSendSysMessage("Autoforbid is %s", flag == 1 ? "enabled" : "disabled");
+        return true;
+    }
+
+    static bool HandleObserversKickCommand(ChatHandler* handler, const char* args)
+    {
+        handler->SetSentErrorMessage(true);
+
+        if (!*args)
+        {
+            handler->SendSysMessage("Syntax: .observers kick #[ name | all ]");
+            handler->SendSysMessage("Kicks player #name from active observers list");
+            return false;
+        }
+
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        Player* observer;
+        ObjectGuid observerGuid;
+        std::string observerName;
+        if (!handler->extractPlayerTarget((char*)args, &observer, &observerGuid, &observerName))
+        {
+            handler->PSendSysMessage("Player %s not found", (char*)args);
+            return false;
+        }
+
+        if (!observer)
+        {
+            handler->PSendSysMessage("Player %s is offline", (char*)args);
+            return false;
+        }
+
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        ObserversMgr* omgr = observer->GetObserversMgr();
+        if (!mgr || !mgr->GetObserver(observerGuid.GetCounter()) || !omgr || ObserversMgr::IsSneak(observer))
+        {
+            handler->PSendSysMessage("Cannot kick player: %s is not your observer", (char*)args);
+            return false;
+        }
+
+        mgr->RemoveObserver(observerGuid.GetCounter(), OBSERVER_REMOVE_KICKED);
+        //mgr->ForbidObserver(observerGuid.GetCounter());
+        return true;
+    }
+
+    static bool HandleObserversKickAllCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr || mgr->GetObserversCountWithoutSneaks() == 0)
+        {
+            handler->SendSysMessage("Syntax: .observers kick all");
+            handler->SendSysMessage("Kicks all active observers");
+            handler->SendSysMessage("You have no active observers right now.");
+            return false;
+        }
+
+        ObserverMap const observeMap = *mgr->GetObserversMap(); //copy
+        for (ObserverMap::const_iterator itr = observeMap.begin(); itr != observeMap.end(); ++itr)
+        {
+            if (ObserversMgr::IsSneak(itr->second))
+                continue;
+
+            mgr->RemoveObserver(itr->first, OBSERVER_REMOVE_KICKED);
+            //mgr->ForbidObserver(itr->first);
+        }
+
+        return true;
+    }
+
+    static bool HandleObserversListActiveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = owner->GetObserversMgr();
+
+        if (!mgr || mgr->GetObserversCountWithoutSneaks() == 0)
+        {
+            handler->SendSysMessage("Syntax: .observers list");
+            handler->SendSysMessage("Lists viewers' information");
+            handler->SendSysMessage("You have no active observers right now.");
+            return false;
+        }
+
+        handler->SendSysMessage("Active observers list:");
+
+        ObserverMap const* observeMap = mgr->GetObserversMap();
+        uint8 loc = handler->GetSessionDbcLocale();
+        uint32 count = 0;
+        for (ObserverMap::const_iterator itr = observeMap->begin(); itr != observeMap->end(); ++itr)
+        {
+            Player* obs = itr->second;
+            if (!obs || !obs->IsInWorld() || obs->GetSession()->isLogingOut())
+                continue;
+
+            if (ObserversMgr::IsSneak(obs))
+                continue;
+
+            std::string plLink;
+            //color
+            switch (obs->GetClass())
+            {
+                case CLASS_WARRIOR:         plLink = "|cffc79c6e|"; break;
+                case CLASS_PALADIN:         plLink = "|cfff58cba|"; break;
+                case CLASS_HUNTER:          plLink = "|cffabd473|"; break;
+                case CLASS_ROGUE:           plLink = "|cfffff569|"; break;
+                case CLASS_PRIEST:          plLink = "|cffffffff|"; break;
+                case CLASS_DEATH_KNIGHT:    plLink = "|cffc41f3b|"; break;
+                case CLASS_SHAMAN:          plLink = "|cff0070de|"; break;
+                case CLASS_MAGE:            plLink = "|cff69ccf0|"; break;
+                case CLASS_WARLOCK:         plLink = "|cff9482c9|"; break;
+                case CLASS_DRUID:           plLink = "|cffff7d0a|"; break;
+                default:                    plLink = "|cffffffff|"; break;
+            }
+            plLink += "Hplayer:"+obs->GetName()+"|h["+obs->GetName()+"]|h|r";
+            handler->PSendSysMessage("%u. %s: %s %s %s (level %u)", ++count, plLink.c_str(),
+                obs->GetGender() == GENDER_MALE ? handler->GetTrinityString(LANG_CHARACTER_GENDER_MALE) : handler->GetTrinityString(LANG_CHARACTER_GENDER_FEMALE),
+                GetRaceName(obs->GetRace(), loc), GetClassName(obs->GetClass(), loc), (uint32)obs->GetLevel());
+        }
+
+        return true;
+    }
+
+    static bool HandleObserversListAllowedCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr)
+            mgr = new ObserversMgr(owner);
+
+        if (mgr->GetAllowedObserversCount() == 0)
+        {
+            handler->SendSysMessage("Syntax: .observers list allowed");
+            handler->SendSysMessage("Lists players allowed to observe you");
+            handler->SendSysMessage("You have no allowed observers.");
+            return false;
+        }
+
+        handler->SendSysMessage("Allowed observers list:");
+
+        ObserverAccessList const* observeList = mgr->GetAccessList();
+        uint32 count = 0;
+        std::string observerName;
+        for (ObserverAccessList::const_iterator itr = observeList->begin(); itr != observeList->end(); ++itr)
+        {
+            if (itr->second != OBSERVER_FLAG_ALLOWED)
+                continue;
+            if (!sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, itr->first), observerName))
+                continue;
+
+            handler->PSendSysMessage("%u. %s", ++count, observerName.c_str());
+        }
+
+        return true;
+    }
+
+    static bool HandleObserversListForbiddenCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr)
+            mgr = new ObserversMgr(owner);
+
+        if (mgr->GetForbiddenObserversCount() == 0)
+        {
+            handler->SendSysMessage("Syntax: .observers list forbidden");
+            handler->SendSysMessage("Lists players not allowed to observe you");
+            handler->SendSysMessage("You have no forbidden observers.");
+            return false;
+        }
+
+        handler->SendSysMessage("Forbidden observers list:");
+
+        ObserverAccessList const* observeList = mgr->GetAccessList();
+        uint32 count = 0;
+        std::string observerName;
+        for (ObserverAccessList::const_iterator itr = observeList->begin(); itr != observeList->end(); ++itr)
+        {
+            if (itr->second != OBSERVER_FLAG_FORBIDDEN)
+                continue;
+            if (!sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, itr->first), observerName))
+                continue;
+
+            handler->PSendSysMessage("%u. %s", ++count, observerName.c_str());
+        }
+
+        return true;
+    }
+
+    static bool HandleObserversListPendingCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr)
+            mgr = new ObserversMgr(owner);
+
+        if (mgr->GetPendingObserversCount() == 0)
+        {
+            handler->SendSysMessage("Syntax: .observers list forbidden");
+            handler->SendSysMessage("Lists players not allowed to observe you");
+            handler->SendSysMessage("You have no pending observers.");
+            return false;
+        }
+
+        handler->SendSysMessage("Pending observers list:");
+
+        ObserverAccessList const* observeList = mgr->GetAccessList();
+        uint32 count = 0;
+        std::string observerName;
+        for (ObserverAccessList::const_iterator itr = observeList->begin(); itr != observeList->end(); ++itr)
+        {
+            if (itr->second != OBSERVER_FLAG_PENDING)
+                continue;
+            if (!sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, itr->first), observerName))
+                continue;
+
+            handler->PSendSysMessage("%u. %s", ++count, observerName.c_str());
+        }
+
+        return true;
+    }
+
+    static bool HandleObserversListAllCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObserversMgr* mgr = owner->GetObserversMgr();
+        if (!mgr)
+            mgr = new ObserversMgr(owner);
+
+        ObserverAccessList const* observeList = mgr->GetAccessList();
+        if (observeList->empty())
+        {
+            handler->SendSysMessage("Syntax: .observers list all");
+            handler->SendSysMessage("Shows full access list");
+            handler->SendSysMessage("Your access list is empty.");
+            return false;
+        }
+
+        handler->SendSysMessage("Your access list:");
+
+        uint32 count = 0;
+        std::string observerName;
+        for (ObserverAccessList::const_iterator itr = observeList->begin(); itr != observeList->end(); ++itr)
+        {
+            if (!sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, itr->first), observerName))
+                continue;
+
+            std::string flagStr;
+            switch (itr->second)
+            {
+                case OBSERVER_FLAG_ALLOWED:
+                    flagStr = "ALLOWED";   break;
+                case OBSERVER_FLAG_FORBIDDEN:
+                    flagStr = "FORBIDDEN"; break;
+                case OBSERVER_FLAG_PENDING:
+                    flagStr = "PENDING";   break;
+                default:
+                    flagStr = "ERROR";     break;
+            }
+            handler->PSendSysMessage("%u. %s: %s", ++count, observerName.c_str(), flagStr.c_str());
+        }
+
+        return true;
+    }
+
+    static bool HandleObserversReloadCfgCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        TC_LOG_INFO("misc", "Re-Loading config settings...");
+        sWorld->LoadConfigSettings(true);
+        ObserversMgr::ReloadConfig();
+        handler->SendSysMessage("Observers config settings reloaded");
+        return true;
+    }
+};
+
+void AddSC_script_observers_commands()
+{
+    new script_observers_commands();
+}
diff --git a/src/server/scripts/Custom/custom_script_loader.cpp b/src/server/scripts/Custom/custom_script_loader.cpp
index 1df319b..33dc1be 100644
--- a/src/server/scripts/Custom/custom_script_loader.cpp
+++ b/src/server/scripts/Custom/custom_script_loader.cpp
@@ -17,9 +17,15 @@
 
 // This is where scripts' loading functions should be declared:
 
+// Observers
+void AddSC_script_observers_commands();
+// End Observers
 
 // The name of this function should match:
 // void Add${NameOfDirectory}Scripts()
 void AddCustomScripts()
 {
+    // Observers
+    AddSC_script_observers_commands();
+    // End Observers
 }
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index fa0ddf4..c7b790d 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -4077,3 +4077,60 @@ Metric.OverallStatusInterval = 1
 
 #
 ###################################################################################################
+
+
+###################################################################################################
+# OBSERVERS MOD CONFIGURATION
+#
+#    Observer.Enable
+#        Description: Allow observers.
+#        Default:     1 - (Enable)
+#                     0 - (Disable)
+
+Observers.Enable = 1
+
+#    Observers.MaxObservers
+#        Description: Maximum number of observers for each player.
+#        Default:     0 - (No maximum)
+
+Observers.MaxObservers = 0
+
+#    Observers.Dungeon
+#    Observers.Raid
+#    Observers.BG
+#    Observers.Arena
+#        Description: Map types observers are allowed in.
+#        Note:        Observers do not count towards map players limit
+#        Default:     1 - (Observers.Dungeon)
+#                     1 - (Observers.Raid)
+#                     1 - (Observers.BG)
+#                     1 - (Observers.Arena)
+
+Observers.Dungeon = 1
+Observers.Raid    = 1
+Observers.BG      = 1
+Observers.Arena   = 1
+
+#    Observers.Sneaks
+#        Description: Allow anonymous observers.
+#        Note:        Only GMs with GM mode enabled can be sneaks
+#        Note2:       Sneaks are not restricted to certain map types
+#        Default:     1 - (Enable)
+#                     0 - (Disable)
+
+Observers.Sneaks = 1
+
+#    Observers.SendPackets.Combat
+#    Observers.SendPackets.Item
+#        Description: Allow to translate observed player events to observers.
+#        Example:     If Observers.SendPackets.Combat is enbaled, observers will
+#                     receive floating combat text
+#        Note:        Enabling combat packets will mess up observers' combat log
+#        Default:     0 - (Observers.SendPackets.Combat)
+#                     1 - (Observers.SendPackets.Item)
+
+Observers.SendPackets.Combat = 0
+Observers.SendPackets.Item   = 1
+
+#
+###################################################################################################
-- 
2.10.0.windows.1

